<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年下半年面试准备]]></title>
    <url>%2F2019%2F08%2F29%2F2019%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[MySQL 索引 锁 InnoDB 底层存储结构 分库分表 中间件 Redis 底层数据结构 缓存淘汰机制 备份机制 sentinel、cluster PHP php7与php5的不同之处 php-fpm 消息队列（RocketMQ） 工作原理 存储结构 优缺点 应用场景 再稍微了解下kafka 大型网站 高并发 限流 幂等 可靠性 微服务 Nginx 工作原理 反向代理 缓存 Docker CI/CD 自动化部署 Yaf 架构思想 底层源码 协议 HTTP TCP UDP SOCKET 网络编程 IM 设计 架构 思想 Linux 平均负载 CPU使用率 内存使用率 僵尸进程 磁盘I/O 阻塞、非阻塞、异步、同步]]></content>
      <categories>
        <category>后花园</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gitlab-docker-ansible-自动化部署]]></title>
    <url>%2F2019%2F08%2F29%2Fgitlab-docker-ansible-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>自动化</tag>
        <tag>Docker</tag>
        <tag>CI/CD</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust可变Vector]]></title>
    <url>%2F2019%2F07%2F22%2Frust-mut-vec%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728fn write_log(content: &amp;mut Vec&lt;u8&gt;) -&gt; std::io::Result&lt;()&gt; &#123; //ASCII控制字符 10 换行 content.push(10); let filename = "/Users/hg/Sites/youyou_log/1.txt"; let file = OpenOptions::new() .read(true) .write(true) .create(true) .append(true) .open(filename); match file &#123; Ok(mut stream) =&gt; &#123; stream.write_all(&amp;content)?; &#125; Err(err) =&gt; &#123; println!("&#123;:?&#125;", err); &#125; &#125; Ok(())&#125;fn main() &#123; let mut content = recv_msg(&amp;socket); write_log(&amp;mut content).unwrap(); //会影响content的值 println!("&#123;&#125;", String::from_utf8(content).unwrap());&#125;]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-两阶段加锁协议]]></title>
    <url>%2F2019%2F06%2F24%2Fmysql-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8A%A0%E9%94%81%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[2PL（2 Phase Locking），两阶段加锁协议：主要用于单机事务中的一致性和隔离性区别于 2PC（2 Phase Commit），两阶段提交协议：主要用于分布式事务]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql-名词浅析]]></title>
    <url>%2F2019%2F06%2F17%2Fmysql-%E5%90%8D%E7%A7%B0%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[两阶段加锁协议（2PL）主要用于单机事务中的一致性与隔离性。 两阶段提交协议（2PC）主要用于分布式事务 多版本并发控制（Multi-Version Concurrency Control，MVCC）可重复读（repeatable read）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交的变更对其他事务是不可见的。 幻读（phantom read）链接 脏读（dirty read）当前读（current read）更新数据都是先读后写，而这个读，只能读当前的值，成为当前读 快照读（snapshot read）一致性不仅是数据库内部数据状态的一致性还包含数据和日志在逻辑上的一致性 读锁（S锁，共享锁）写锁（X锁，排他锁）间隙锁（Gap Lock）next-key lock记录锁（record locks）互斥锁（lock_mode X）行锁死锁当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源是，就会导致这几个线程都进入无线等待的状态。 全局锁对整个数据库实例加锁。命令Flush tables with read lock。主要用在逻辑备份过程中 表锁对表进行加锁。命令lock tables ... read/write 元数据锁（meta data lock，MDL）也是表级锁，不需要显示使用，在访问一个数据表的时候会被自动加上。MDL的作用是保证读写的正确性。 备份线程读提交binlog连接器管理连接，权限验证 查询缓存分析器词法分析，语法分析 优化器执行计划生成，索引选择 执行器操作引擎，返回结果 存储引擎redo log（重做日志）binlog（归档日志）undo log（回滚日志）WAL技术（Write-Ahead-Logging，WAL）write poscheckpointbuffer poolInnoDB 用缓冲池管理内存 覆盖索引可以直接提供查询结果，不需要回表。 索引下推一致性视图（consistent read view）是INNIDB在实现MVCC时用到的，用于支持RC（Read Commited，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。 change buffer刷脏页数据页DDLDMLDCLOnline DDLOLAP 联机分析处理OLAP（On-Line Analytical Processing）OLTP 联机事务处理OLTP（On-Line Transaction Processing）]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整数反转]]></title>
    <url>%2F2019%2F05%2F31%2Fleetcode-reverse-integer%2F</url>
    <content type="text"><![CDATA[[题目链接](https://leetcode-cn.com/problems/reverse-integer/ 题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 转字符串法1234567891011121314151617181920212223* 时间复杂度：O(1)* 空间复杂度：O(1)class Solution &#123; /** * @param Integer $x * @return Integer */ function reverse($x) &#123; $max = 2147483648; $absx = abs($x); if ($absx &gt;= $max) &#123; return 0; &#125; $rev = strrev($absx); if ($rev &gt;= $max) &#123; return 0; &#125; return ($x &lt;=&gt; 0) * $rev; &#125;&#125; 运行结果： 1234✔ Accepted ✔ 1032/1032 cases passed (0 ms) ✔ Your runtime beats 100 % of php submissions ✔ Your memory usage beats 44.81 % of php submissions (14.7 MB)]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F05%2F31%2Fleetcode-two-sum%2F</url>
    <content type="text"><![CDATA[题目链接 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 暴力法我第一时间想到的解法就是借助PHP原生方法实现，但感觉会失去一些意义。 时间复杂度：O($n^2$) 空间复杂度：O(1) 1234567891011121314151617181920212223class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) &#123; $len = count($nums); if ($len == 0) &#123; return []; &#125; //$len - 1 防止数组越界 for ($i = 0; $i &lt; $len - 1; $i++) &#123; for ($j = $i + 1; $j &lt; $len; $j++) &#123; if ($nums[$i] + $nums[$j] == $target) &#123; return [$i, $j]; &#125; &#125; &#125; return []; &#125;&#125; 运行结果： 1234✔ Accepted ✔ 29/29 cases passed (2216 ms) ✔ Your runtime beats 26.82 % of php submissions ✔ Your memory usage beats 39 % of php submissions (15.8 MB) 一遍Hash法这是在官方解答中看到的，用PHP实现。 时间复杂度：O(n) 空间复杂度：O(n) 使用了map来存储 123456789101112131415161718192021222324class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) &#123; $len = count($nums); if ($len == 0) &#123; return []; &#125; $map = []; for ($i = 0; $i &lt; $len; $i++) &#123; $find_num = $target - $nums[$i]; if (in_array($find_num, $map)) &#123; //在数组中查询$find_num 所对应的索引key return [array_search($find_num, $map), $i]; &#125; $map[] = $nums[$i]; &#125; return []; &#125;&#125; 运行结果： 1234✔ Accepted ✔ 29/29 cases passed (60 ms) ✔ Your runtime beats 79.37 % of php submissions ✔ Your memory usage beats 86.67 % of php submissions (15.6 MB) PHP原生法(更优)借助原生函数`` 时间复杂度：O(n) 空间复杂度：O(n) 使用了map来存储 1234567891011121314151617181920class Solution &#123;/** * @param Integer[] $nums * @param Integer $target * @return Integer[] */function twoSum($nums, $target) &#123; $map = []; $len = count($nums); for ($i = 0; $i &lt; $len; $i++) &#123; $find_num = $target - $nums[$i]; if (array_key_exists($find_num, $map)) &#123; return [$map[$find_num], $i]; &#125; $map[$nums[$i]] = $i; &#125; &#125;&#125; 运行结果：1234✔ Accepted ✔ 29/29 cases passed (16 ms) ✔ Your runtime beats 98.71 % of php submissions ✔ Your memory usage beats 28.13 % of php submissions (15.8 MB)]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql-索引]]></title>
    <url>%2F2019%2F05%2F29%2Fmysql-%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引的存储分类索引是在MySQL的存储引擎层中实现的，而不是在服务层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。目前MySQL提供了一下4种索引： B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。 HASH索引：只有Memory引擎支持，使用场景简单。 R-Tree索引(空间索引)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。 Full-text索引(全文索引)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。 常见的索引模型索引的出现是为了提高查询效率，但实现索引的方式却有很多种。索引模型可以看作是种数据结构，常见的有哈希表、有序数组和搜索树。 InnoDB的索引模型 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clusterd index）。 非主键索引的叶子节点内容时主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。 覆盖索引如果被查询的索引已经覆盖了我们的查询，我们称为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能，所以覆盖索引是一个常用的性能优化手段。 最左前缀原则索引下推索引的维护重建普通索引可以使用12alter table T drop index k;alter table T add index(k); 如果重建主键索引1alter table T engine=InnoDB]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql-事务隔离]]></title>
    <url>%2F2019%2F05%2F27%2Fmysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[在MySQL中事务支持是在引擎层实现的。 隔离性与隔离级别当数据库上有多个事务同时执行的时候，就可能出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read)的问题，为了解决这些问题，就有了“隔离级别”的概念。 ACID（Atomicity、Consisency、Isolation、Durability，即原子性、一致性、隔离性、持久性） SQL标准的隔离级别包括： 读未提交(read uncommitted)：一个事务还没提交时，它所做的变更就能被别的事务看到。 读提交(read committed)：一个事务提交后，它做的变更才会被其他事务看到。 可重复读(repeatable read)：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交的变更对其他事务是不可见的。 串行化(serializable)：对于同一行记录，“写”会“加锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行。 这四种隔离级别，并行性能依次降低，安全性依次提高。 在实现上，数据库里会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是在事务启动时创建的，在整个事务存在期间都用这个视图。在读提交隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，读未提交隔离级别下直接返回记录上的最新值，没有视图概念；而串行化隔离级别下直接用加锁的方式来避免并行访问。 1234567891011mysql&gt; show variables like &apos;transaction_isolation&apos;;+-----------------------+----------------+| Variable_name | Value |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+ 事务隔离的实现在MySQL中，实际上每条记录在更新的时候都会记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 对于同一条记录可以存在多个版本，这就是数据库的多版本并发控制(MVCC)。 回滚日志是系统来判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。就是当系统里没有比这个回滚日志更早的read-view的时候。 事务的启动时机begin/start transaction命令并不是一个事务的起点，在执行它们之后的第一个操作InnoDB表的语句，事务才真正启动。如果想马上启动一个事务，可以使用start transaction with consistent snapshot命令。 第一种启动方式，一致性视图是在执行第一个读语句时创建的； 第二种启动方式，一致性视图是在执行start transaction with consistent snapshot时创建的。 12345678+----+------+| id | c |+----+------+| 1 | 4 || 2 | 5 || 3 | 6 || 4 | 7 |+----+------+ 事务A 事务B 普通 begin; begin; select * from t where id =1 =&gt; (c = 4) select * from where id = 1 =&gt; (c = 4) update t set c = c +1 where id =1 select * from t where id =1 =&gt; (c = 5) update t set c = c + 2 where id =1 select * from t where id = 1 =&gt; (c = 7) select * from t where id = 1 =&gt; (c = 5) update t set c = c + 5 where id = 1 （等待事务B结束） select * from t where id =1 =&gt; (c = 5) commit; select * from t where id =1 =&gt; (c = 7) (自动提交) select * from t where id = 1 =&gt; (c = 12) commit; select * from t where id =1 =&gt; (c = 12) select * from t where id =1 =&gt; (c = 12) select * from t where id =1 =&gt; (c = 12) 一个事务A要更新一行，如果刚好有另外一个事务B拥有这一行的行锁，事务A会被锁住，需等待事务B的结束，再次执行事务A，进行更新数据。 事务的启动方式 显示启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。 set autocommit = 0，这个命令会将这个线程的自动提交关掉。这个事务持续存在直到你主动执行commit或rollback语句，或者快开连接。 查询超过60s的事务1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法-复杂度分析]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%AE%97%E6%B3%95-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%901%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[redis对象]]></title>
    <url>%2F2018%2F09%2F16%2Fredis-object%2F</url>
    <content type="text"><![CDATA[Redis主要的数据结构，如：简单动态字符串、双端链表、字典、压缩列表、整数集合等。但Redis并没有直接使用数据结构来实现键值对数据库， 而是基于这些数据结构实现了一个对象系统。Redis有五大对象，分为：字符串对象、列表对象、哈希对象、集合对象和有序集合对象。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode语言调试记录]]></title>
    <url>%2F2018%2F09%2F15%2Fvscode-debug-notes%2F</url>
    <content type="text"><![CDATA[C语言生成c_cpp_properties.jsoncmd + shift +p 进入命令行模式, 选择[C/Cpp: Edit Configurations] 1234567891011121314151617181920&#123; "configurations": [ &#123; "name": "Mac", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [], "macFrameworkPath": [ "/System/Library/Frameworks", "/Library/Frameworks" ], "compilerPath": "/usr/bin/clang", "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "clang-x64" &#125; ], "version": 4&#125; 生成tasks.json进入命令行模式, 选择[Tasks: Configure Task Runner] 123456789101112131415161718192021222324&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "label": "clang", "type": "shell", //使用clang编译C文件，如果你使用C++开发，改成clang++ "command": "clang", //如果使用的是C++，则改成main.cpp或者相对应的cpp入口文件。如果需要支持C++11，添加"-std=c++11" "args": [ "main.c", "-g" ], "presentation": &#123; // Reveal the output only if unrecognized errors occur. "reveal": "always" &#125;, // Use the standard MS compiler pattern to detect errors, warnings and infos "problemMatcher": "$msCompile" &#125; ]&#125; 生成launch.json进入命令行模式, 选择[Debug: Open launch.json] 1234567891011121314151617181920212223&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "c/c++ Launch", "type": "cppdbg", "request": "launch", "targetArchitecture": "x86_64", "program": "$&#123;workspaceFolder&#125;/a.out", "args": [], "stopAtEntry": false, "cwd": "$&#123;workspaceFolder&#125;", "environment": [], "externalConsole": true, "MIMode": "lldb", //名字对应tasks.label "preLaunchTask":"clang" &#125; ]&#125; Rust语言生成launch.json1234567891011121314151617181920212223242526272829303132333435&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "type": "lldb", "request": "launch", "name": "Debug string", "cargo": &#123; "args": [ "build", "--bin=string" ] &#125;, "args": [], "cwd": "$&#123;workspaceFolder&#125;" &#125;, &#123; "type": "lldb", "request": "launch", "name": "Debug tests in string", "cargo": &#123; "args": [ "test", "--no-run", "--bin=string" ] &#125;, "args": [], "cwd": "$&#123;workspaceFolder&#125;" &#125; ]&#125;]]></content>
      <categories>
        <category>后花园</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2018%2F09%2F13%2Fvscode%2F</url>
    <content type="text"><![CDATA[快捷键两键（ctrl + ） 向后浏览ctrl + - 打开终端ctrl +` 历史打开记录ctrl + tab 跳到指定行号ctrl + g 两键（cmd + ） 开启侧边栏cmd + b 打开文件cmd + p 分割编辑器窗口cmd + \ 编辑器窗口切换cmd + 1cmd + 2cmd + 3 选择当前行cmd + i 回到文件开始cmd + up 回到文件结束cmd + down 两键（opt + ） 上下移动一行opt + upopt + down 三键（cmd + shift + ） 打开markdown预览cmd + shift + v 打开底部cmd + shift + u 切换到资源管理器栏cmd + shift + e 打开新的编辑器窗口cmd + shift + n 关闭编辑器窗口 cmd + shift + w 括号匹配cmd + shift + \ 符号查找cmd + shift + o 修整行尾空格cmd + shift + x 调出安装命令栏cmd + shift + p 三键（opt + cmd + ） 多游标选择opt + cmd + upopt + cmd + down 三键（opt + shift + ） 复制一行opt + shift + upopt + shift +down 三键以上组合 缩小/扩大选择ctrl + shift + cmd + leftctrl + shift + cmd + right]]></content>
      <categories>
        <category>后花园</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2018%2F07%2F23%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[进制概述维基百科中：是一种计数方式。利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。 位权: 简称“权”，数制中每一固定位置对应的单位值。例如十进制数 111，三个“1”放在不同的位置，所代表的意义也不同。从左到右分别为 100，10，1。还可以表示为：1×102，1×101，1×100。这里面10x 就叫做权，二进制则为2x，八进制为8x，以此类推。 基数: 是指一种进制中组成的基本数字，也就是不能再进行拆分的数字。二进制是0和1；八进制是0-7；十进制是0-9；十六进制是0-9和A-F。可简单记忆：假设是n进制的话，基数就是【0，n-1】的数字。 基数的个数和进制值相同。二进制有两个基数，十进制有十个基数。 运算规则: 进位或错位规则。例如对于二进制来说，该规则就是“满二进一，借一当二”；对十进制来说，该规则就是“满十进一，借一当十”；其他进制一次类推。 在10进制中有10个数字(0 - 9)，比如: 2506D = 2\times 10^{3}+5\times 10^{2}+0\times 10^{1}+6\times 10^{0}在16进制中有16个数字(0–9 和 A–F)，比如: 171B = 1\times 16^{3}+7\times 16^{2}+1\times 16^{1}+B\times 16^{0}一般说来，b进制有b个数字，如果a3a2a2a0是其中四个数字序列，那么就有: a_3a_2a_1a_0=a_3\times b^3+a_2\times b^2+a_1\times b^1+a_0\times b^0进制基数对照表 二进制（B） 八进制（O） 十进制（D） 十六进制（H） 0000 0 0 0 0001 1 1 1 0010 2 2 2 0011 3 3 3 0100 4 4 4 0101 5 5 5 0110 6 6 6 0111 7 7 7 1000 10 8 8 1001 11 9 9 1010 12 10 A 1011 13 11 B 1100 14 12 C 1101 15 13 D 1110 16 14 E 1111 17 15 F 二进制转其他进制二进制转八进制首先，我们需要了解一个数学关系，即23 = 8，24=16，而八进制和十六进制是用这关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。 将二进制数10010转换成八进制。 10010 = 010 010 = 0\times2^2+1\times2^1+0\times2^0\;\;0\times2^2+1\times2^1+0\times2^0 = 22 将二进制数0.101010转换成八进制。 0.101 010 = 0.\; 1\times2^2+0\times2^1+1\times2^0\;\;0\times2^2+1\times2^1+0\times2^0 = 0.52 方法：因为每三位二进制数对应一位八进制数，所以，以小数点为界，整数位则将二进制数从右向左每3位一隔开，不足3位的在左边用0填补即可；小数位则将二进制数从左向右每3位一隔开，不足3位的在右边用0填补即可。 二进制转十进制 将二进制数101.101转换成十进制。 101.101 = 1\times2^2+0\times2^1+1\times2^0. 1\times2^{-1}+0\times2^{-2}+1\times2^{-3} = 5.625方法：以小数点为界，整数位从最后一位（从右向左）开始算，依次列为第0、1、2、3………n，然后将第n位的数（0或1）乘以2n-1 次方，然后相加即可得到整数位的十进制数；小数位则从左向右开始算，依次列为第1、2、3……..n，然后将第n位的数（0或1）乘以2-n次方，然后相加即可得到小数位的十进制数（按权相加法）。 二进制转十六进制 将二进制数1.10101转换成十六进制。 第一步计算1： 1 = 0001 = 0\times2^3 + 0\times2^2 + 0\times2^1 + 1\times2^0 = 1 第二步计算0.10101： 10101 = 1010\;1000 = 1\times2^3 + 0\times2^2 + 1\times2^1 + 0\times2^0 \; 1\times2^3 + 0\times2^2 + 0\times2^1 + 0\times2^0= 10 \; 8 = A8 拼接在一起为：1.A8 方法：取四合一法，因为每四位二进制数对应一位十六进制数，所以，以小数点为界，整数位则将二进制数从右向左每4位一隔开，不足4位的在左边用0填补即可；小数位则将二进制数从左向右每4位一隔开，不足4位的在右边用0填补即可。 八进制转其他进制八进制转二进制 将八进制数67.54转换成二进制。 第一步计算67： 67 = xxx\;xxx = x\times2^2 + x\times2^1+ x\times2^0\;x\times2^2 + x\times2^1+ x\times2^0 = 110\;111 第二步计算0.54： 54 = xxx\;xxx = x\times2^2 + x\times2^1+ x\times2^0\;x\times2^2 + x\times2^1+ x\times2^0 = 101\;100 = 1011 拼接在一起为：110 111. 1011 方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。 八进制转十六进制 将八进制67.54转换成十六进制。 第一步先转换为二进制： 67.54 = 110111.1011 第二步计算110111： 110111 = 0011\;0111 = 0\times2^3+0\times2^2+1\times2^1+1\times2^0\;0\times2^3+1\times2^2+1\times2^1+1\times2^0 = 37 第三步计算0.1011： 1011 = 1\times2^3+0\times2^2+1\times2^1+1\times2^0 = 11 = B 拼接在一起为：37.B 方法：一般不能互相直接转换，一般是将八进制（或十六进制）转换为二进制，然后再将二进制转换为十六进制（或八进制），小数点位置不变。那么相应的转换请参照上面二进制与八进制的转换和二进制与十六进制的转。 八进制转十进制 将八进制67.54转换成十进制 第一步计算67: 67 = 6\times8^1+7\times8^0 = 55 第二步计算0.54： 54 = 5\times8^{-1}+4\times8^{-2} = 6875 拼接在一起为：55.6875 方法：同二进制转换成十进制。以小数点为界，整数位从最后一位（从右向左）开始算，依次列为第0、1、2、3………n，然后将第n位的数（0-7）乘以8的n-1次方，然后相加即可得到整数位的十进制数；小数位则从左向右开始算，依次列为第1、2、3……..n，然后将第n位的数（0-7）乘以8的-n次方，然后相加即可得到小数位的十进制数（按权相加法）。 十进制转其他进制十进制转二进制 将十进制7.125转换成二进制 第一步计算7： 12347除以2，商3余1。3除以2，商1余1。1除以2，商0余1。从后往前读余数：111 第二步计算0.125： 12340.125乘以2，得0.25，整数部分是0，小数部分是0.250.25乘以2，得0.5，整数部分是0，小数部分是0.50.5乘以2，得1.0，整数部分是1，小数部分是0从前往后读整数部分：001 拼接在一起为：111.001 方法：（整数）除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。（小数）乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数。 十进制转八进制 将十进制93.3125转换成八进制： 第一步计算93: 123493除以8，商11余5。11除以8，商1余3。1除以8，商0余1。从后往前读余数：135 第二步计算0.3125： 1230.3125乘以8，得2.5，整数部分是2，小数部分是0.50.5乘以8，得4.0，整数部分是4，小数部分是0从前往后读整数部分：24 拼接在一起为：135.24 方法：（整数）除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。（小数）乘8取整法，即将小数部分乘以8，然后取整数部分，剩下的小数部分继续乘以8，然后取整数部分，剩下的小数部分又乘以8，一直取到小数部分为零为止。如果永远不能为零，就同十进制数的四舍五入一样，暂取个名字叫3舍4入。 十进制转十六进制 将十进制93.3125转换成八进制： 第一步计算93: 12393除以16，商5余13。5除以16，商0余5。从后往前读余数：513 = 5D 第二步计算0.3125： 120.3125乘以16，得5.0，整数部分是5，小数部分是0从前往后读整数部分：5 拼接在一起为：5D.5 方法：同十进制转八进制、二进制，此时除数为16。 十六进制转其他进制十六进制转二进制方法：十六进制转换成二进制与二进制转换成十六进制相反。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机差错校验]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%B7%AE%E9%94%99%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[受元器件质量、电路故障或噪音干扰等因素的影响，计算机在对数据进行传输、处理以及存储过程中，往往出现误差。为了纠正或发现错误，人们提出了基于编码的解决方案。 奇偶校验映射规则：校验码中1的数量是偶数或者奇数。 奇偶校验是两种校验方式，接收方和发送方确认其中一种校验方式后，进行奇偶校验。 比如被校验的数据是：10110101。如果采用奇校验，根据规则编码之后的码流为：010110101。在高位添加校验码0。 实例分析 采用奇校验，正确码流为010110101。(5个1) 错1位：010110100，接收方计算出是偶数(4)个1与预期不符，说明码流有问题。 错2位：010110110，接收方计算出奇数(5)个1，虽然与预期相符，但码流的确不正确。 错3位：010110010，接收方计算出是偶数(4)个1与预期不符，说明码流有问题。 采用偶校验，正确码流为110110101。(6个1) 错1位：110110100，接收方计算出是奇数(5)个1与预期不符，说明码流有问题。 错2位：110110110，接收方计算出偶数(6)个1，虽然与预期相符，但码流的确不正确。 错3位：110110010，接收方计算出是奇数(5)个1与预期不符，说明码流有问题。 综上：奇偶校验只能发现为奇数出错，且无法发现出错的位置。 海明码校验映射规则： 将有效信息按某种规律分成若干组，每组安排一个校验位，做奇偶测试，就能提供多位检错信息，以指出最大可能是哪位出错，从而将其纠正。实质上，海明校验是一种多重校验。 分组规则：位号为2的幂次方的位（1，2，4，8，16，……）为校验位，余下的（3，5，6，7，9，……）为信息位。 最小校验位个数需满足公式：n\\;+\\;k\\;\\leq\\;2^k\\;-\\;1 其中n表示信息位个数，k表示校验位个数 比如：信息位n = 7，那么k最小需为4。 实例分析演算码流信息位1010010，使用海明校验码如何进行计算？下面开始演算。 使用Hi来表示，海明码码流。 信息位是7位，根据公式，k = 4。 根据映射规则，4个校验位分布到：H1、H2、H4、H8；7个信息位分布到：H3、H5、H6、H7、H9、H10、H11。 H11 H10 H9 H8 H7 H6 H5 H4 H3 H2 H1 1 0 1 K4 0 0 1 K3 0 K2 K1 校验位对应关系表： 1 2 4 8 1 √ 2 √ 3 √ √ 4 √ 5 √ √ 6 √ √ 7 √ √ √ 8 √ 9 √ √ 10 √ √ 11 √ √ √ 问：为什么是这种对应关系？ 答：海明码位数 = 海明校验码位数之和。比如：11 = 1 + 2 + 8。7 = 1 + 2 + 4。 从上表可得知校验位1负责1、3、5、7、9、11位，校验位2负责2、3、6、7、10、11位，等等。 我们采用偶校验： 第一组：K1H3H5H7H9H11，因H3H5H7H9H11含有奇数个1，故H1（K1） 取值 1。 第二组：K2H3H6H7H10H11，因H3H6H7H10H11含有奇数个1，故H2（K2） 取值 1。 第三组：K3H5H6H7，因H5H6H7含有奇数个1，故H4（K3） 取值 1。 第四组：K4H9H10H11，因H9H10H11，含有偶数个1，故H8（K4） 取值 0。 综上可知： H11 H10 H9 H8 H7 H6 H5 H4 H3 H2 H1 1 0 1 0 0 0 1 1 0 1 1 即海明码码流为：10100011011 验算问：接收方怎么校验码流是否出错？ 答：码流长度为11，根据公式可知，信息位长度：7，校验位长度：4。 分成4组，G1、G2、G3、G4： G1 = K1⊕H3⊕H5⊕H7⊕H9⊕H11 = 1⊕0⊕1⊕0⊕1⊕1 = 0 G2 = K2⊕H3⊕H6⊕H7⊕H10⊕H11 = 1⊕0⊕0⊕0⊕0⊕1⊕1 = 0 G3 = K3⊕H5⊕H6⊕H7 = 1⊕1⊕0⊕0 = 0 G4 = K4⊕H9⊕H10⊕H11 = 0⊕1⊕0⊕1 = 0 故正确情况下：G4G3G2G1 = 0000 如果接收方收到的码流为：10100011111，第3位改变了。 接收方计算时： G1 = K1⊕H3⊕H5⊕H7⊕H9⊕H11 = 1⊕1⊕1⊕0⊕1⊕1 = 1 G2 = K2⊕H3⊕H6⊕H7⊕H10⊕H11 = 1⊕1⊕0⊕0⊕0⊕1⊕1 = 1 G3 = K3⊕H5⊕H6⊕H7 = 1⊕1⊕0⊕0 = 0 G4 = K4⊕H9⊕H10⊕H11 = 0⊕1⊕0⊕1 = 0 此时 G4G3G2G1 = 0011，接收方可知是错误的码流。 又由于0011(B) = 3(D)，可知是第三位出错了，把第三位取反即可纠正。 循环冗余校验（CRC）基本思想是在要发送的码流后面附件一个数（这个数就是校验码同时也是一个二进制序列码），这个校验码不是随意指定的，他要满足接收方和发送方能与某个特定数整除（采用“模2除法”计算出），生成一个新的码流发送给接收端。到达接收端后，再把接收的新码流除以（采用“模2除法”）这个选定数，所以结果没有余数说明码流在传输过程中没有出错，反之出错。 “模2除法”与“算术除法”类似，无进位、无借位，同0异1。如100101除以1110，结果得到商为11，余数为1。 CRC校验原理就是以下几个步骤： 先选择一个除数，这个除数通常以多项式方式表示。 假设除数位数为k位二进制，要发送的码流为n位二进制；在要发送的码流后面追加上k-1位0，此时用新的码流(长度为：n + k - 1)以“模2除法”除以除数，所得的余数就是CRC校验码。余数需要满足：余数的位数一定要比除数位有且只能少一位。 再把这个校验码写到原码流（n位）的后面，替换之前的k-1位的0,发送给接收端；接送端再以“模2除法”除以除数，如果没有余数说明没有出错，反之出错。 选定的除数需满足最高位和最低位必须均为1 实例分析例题：CRC生成多项式为G（X） = X4 + X3 + 1，求二进制10110011的CRC校验码。 由多项式G（X） = X4 + X3 + 1，除数一共5位（最高次幂加1，即4 + 1 = 5），多项式只列出二进制值为1的位，也就是这个二进制的第4位、第3位、第0位的二进制均为1，其它位均为0），可得除数为11001。 因为生成多项式的位数为5，得知CRC校验码的位数为4。码流10110011，在后面加4个0，成为101100110000，然后把这个数做“模2除法”除以11001，得到的余数（即CRC码）为0100。 把计算得来的余数0100替换101100110000后面的4个0，变成101100110100。把这个新的码流发送给接收端。 接收端把这个码流再用上面选定的除数11001以“模2除法”方式去除，如果余数为0，证明无误；不为0，证明有误。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>校验码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis应用实例]]></title>
    <url>%2F2018%2F07%2F06%2Fredis-study-notes%2F</url>
    <content type="text"><![CDATA[昨天在公司做一次redis分享，之前做的源码分享同事反馈实用性太弱算法不好理解，我就来讲讲实战方面的。 设想数据级别在上亿级别，以下key都在同一台redis实例中。 部分数据 id name sex age languages location 1 常 汉子 20 JS + Node + Java + PHP (121.45, 31.20) 2 青 汉子 20 JS + Node (120.45, 31.20) 3 包 汉子 20 JS + PHP (119.45, 31.20) 4 喜 汉子 21 JS + Node (118.45, 31.20) 5 缪 汉子 20 PHP + Go (117.45, 31.50) 6 鹏 汉子 21 PHP + Go + JS (116.45, 31.20) 7 亮 汉子 22 PHP + Node + Python (115.45, 31.20) 8 宏 汉子 21 PHP + Python (114.45, 31.20) 9 韩 汉子 20 (113.45, 31.20) 10 胜 汉子 21 PHP + Java (112.45, 31.20) 11 欣 妹子 18 Python + Java (111.45, 31.20) 12 文 妹子 18 Go + Java (110.45, 31.20) 12345// 用户ID =&gt; 用户名$id_name = [ 1 =&gt; '常', 2 =&gt; '青', 3 =&gt; '包', 4 =&gt; '喜', 5 =&gt; '缪', 6 =&gt; '鹏', 7 =&gt; '亮', 8 =&gt; '宏', 9 =&gt; '韩', 10 =&gt; '胜', 11 =&gt; '欣', 12 =&gt; '文']; 产品需求 如何实现微博中的粉丝、关注关系？ 如何实现微博中互相关注列表？ 如何实现，同时掌握PHP和Python的人？ 如何实现，掌握Python的妹子？ 如何实现，掌握Python的或Java的人？ 如何实现，亮和文之间的距离？ 如何实现，亮看看111km以内有哪些小伙伴？ 关注关系的实现 常 123456789101112131415161718192021222324252627# 关注集合127.0.0.1:6379&gt; SADD follow_1 2 3 4 6 7(integer) 5127.0.0.1:6379&gt; SMEMBERS follow_11) "2"2) "3"3) "4"4) "6"5) "7"# 关注数127.0.0.1:6379&gt; SCARD follow_1(integer) 5127.0.0.1:6379&gt;# 粉丝集合127.0.0.1:6379&gt; SADD fans_1 5 6 7(integer) 3127.0.0.1:6379&gt; SMEMBERS fans_11) "5"2) "6"3) "7"# 粉丝数127.0.0.1:6379&gt; SCARD fans_1(integer) 3 亮 12345678910111213141516171819202122232425262728# 关注集合127.0.0.1:6379&gt; SADD follow_7 5 6 2(integer) 3127.0.0.1:6379&gt; SMEMBERS follow_71) "2"2) "5"3) "6"# 关注数127.0.0.1:6379&gt; SCARD follow_7(integer) 3# 粉丝集合127.0.0.1:6379&gt; SADD fans_7 2 3 1 4 6(integer) 5127.0.0.1:6379&gt; SMEMBERS fans_71) "1"2) "2"3) "3"4) "4"5) "6"127.0.0.1:6379&gt;# 粉丝数127.0.0.1:6379&gt; SCARD fans_7(integer) 5 喜 1234567891011121314151617# 关注集合127.0.0.1:6379&gt; SADD follow_4 6 7 1(integer) 3127.0.0.1:6379&gt; SMEMBERS follow_41) "1"2) "6"3) "7"# 粉丝集合127.0.0.1:6379&gt; SADD fans_4 1 6 7 5(integer) 4127.0.0.1:6379&gt; SMEMBERS fans_41) "1"2) "5"3) "6"4) "7" 1234567891011121314151617# 常与亮，共同关注的127.0.0.1:6379&gt; SINTER follow_1 follow_71) "2"2) "6"127.0.0.1:6379&gt;# 互粉常与亮的（关注常的也关注了亮）127.0.0.1:6379&gt; SINTER fans_1 fans_71) "6"127.0.0.1:6379&gt;# 亮进喜的主页，查看亮的关注也关注了喜#### 判断交集集合中是否包含6127.0.0.1:6379&gt; SINTER fans_7 fans_11) "6"127.0.0.1:6379&gt; 用户标签的聚合可以把用户的性别、掌握的语言作为作为标签去处理。在redis中bitmap非常适合现在的场景，不仅可以进行异或运算，而且非常节约内存资源。1亿用户占用12MB，可以说非常棒了。 准备数据123456789$php = [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0];$python = [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0];$sex = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0];$js = [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0];$node = [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0];$java = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1];$go = [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1];//这个one集合，是为了实现把0做异或运算时用到$one = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; 1234567891011121314151617181920$pipe = $redis-&gt;multi(Redis::PIPELINE);for ($k = 0; $k &lt; 100000000; $k++) &#123; $_k = $k + 1; $pipe-&gt;setBit('php', $_k, $php[$k]?:rand(0, 1)); $pipe-&gt;setBit('python', $_k, $python[$k]?:rand(0, 1)); $pipe-&gt;setBit('sex', $_k, $sex[$k]?:rand(0, 1)); $pipe-&gt;setBit('js', $_k, $js[$k]?:rand(0, 1)); $pipe-&gt;setBit('node', $_k, $node[$k]?:rand(0, 1)); $pipe-&gt;setBit('java', $_k, $java[$k]?:rand(0, 1)); $pipe-&gt;setBit('go', $_k, $go[$k]?:rand(0, 1)); $pipe-&gt;setBit('one', $_k, 1);&#125;$pipe-&gt;exec(); 解决问题 如何实现，同时掌握PHP和Python语言的人？ 12345678$redis-&gt;bitOp('AND', 'php_python_and', 'php', 'python');$str = '同时掌握`PHP`和`Python`语言的人：';foreach ($id_name as $id =&gt; $name) &#123; if ($redis-&gt;getBit('php_python_and', $id)) &#123; $str .= $name. ' '; &#125;&#125;echo $str; 如何实现，掌握Python的妹子？ 1234567891011//先把妹子和汉子异或处理，这时妹子置为1 汉子置为0$redis-&gt;bitOp('XOR', 'tmp_sex', 'sex', 'one');$redis-&gt;bitOp('AND', 'sex_python', 'tmp_sex', 'python');$str = '如何实现，掌握`Python`的妹子：';foreach ($id_name as $id =&gt; $name) &#123; if ($redis-&gt;getBit('sex_python', $id)) &#123; $str .= $name. ' '; &#125;&#125;echo $str; 如何实现，掌握Python的或Java的人？ 12345678$redis-&gt;bitOp('OR', 'java_python', 'java', 'python');$str = '如何实现，掌握`Python`的或`Java`的人：';foreach ($id_name as $id =&gt; $name) &#123; if ($redis-&gt;getBit('java_python', $id)) &#123; $str .= $name. ' '; &#125;&#125;echo $str; 距离关系准备数据1234567$pipe = $redis-&gt;multi(Redis::PIPELINE);$j = 1;for ($i = 121; $i &gt;= 110; $i--) &#123; $pipe-&gt;geoAdd('geo', $i + 0.45, 31.20, $j); $j++;&#125;$pipe-&gt;exec(); 解决问题 如何实现，亮和文之间的距离？ 12$dist = $redis-&gt;geoDist('geo', 7, 12, 'km');echo '亮和文相距：'. $dist. 'km'; 如何实现，亮看看111km以内有哪些小伙伴？ 12345678$nearby = $redis-&gt;GEORADIUSBYMEMBER('geo', 7, 111, 'km');$str = '亮111km以内有：';foreach ($nearby as $id) &#123; if ($id != 7) &#123; $str .= $id_name[(int)$id].' '; &#125;&#125;echo $str;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>位图</tag>
        <tag>BitMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读研]]></title>
    <url>%2F2018%2F06%2F30%2F%E8%AF%BB%E7%A0%94%2F</url>
    <content type="text"><![CDATA[网络资源 王道论坛：主要考研书籍和考研心得、经验的交流 研招网:官方考研网站，报考、信息公布等 硕士专业目录查询 统考报名 上海高校 交通大学硕士专业 交通大学-计算机应用技术方向目录 知乎live-计算机考研 研招-2018计算机考研大纲 408书籍 王道考研 其他参考 网友心得 2018考研计算机408经验详谈 2018考研数学经验详谈 2018浙大计算机考研经验]]></content>
      <categories>
        <category>后花园</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hbase小试牛刀]]></title>
    <url>%2F2018%2F06%2F25%2Fhbase%2F</url>
    <content type="text"><![CDATA[心痒难耐就研究了下Hbase，算是对NoSQL知识的一点扩充吧。 系统信息12系统环境：腾讯云主机系统版本：CentOS Linux release 7.5.1804 软件包准备java安装包： jdk-8u172-linux-x64.rpm Hbase：hbase-2.0.1-bin.tar.gz Phoenix：apache-phoenix-5.0.0-alpha-HBase-2.0-bin.tar.gz 安装Java 默认安装到 /usr/java/中 1# rpm -ivh jdk-8u172-linux-x64.rpm 验证1234# java -versionjava version "1.8.0_172"Java(TM) SE Runtime Environment (build 1.8.0_172-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode) 配置环境变量1vim /etc/profile 向文件追加一下内容： 12345JAVA_HOME=/usr/java/jdk1.8.0_172-amd64JRE_HOME=/usr/java/jdk1.8.0_172-amd64/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 使修改立即生效 1# source /etc/profile 查看PATH值 12# echo $PATH/usr/java/jdk1.8.0_172-amd64/jre/bin:/root/bin 查看JAVA_HOME 12# echo $JAVA_HOME/usr/java/jdk1.8.0_172-amd64 安装Hbase 将文件解压到目录：/root/hbase 1tar -zxf hbase-2.0.1-bin.tar.gz 配置1vim hbase-2.0.1/conf/hbase-env.sh 找到JAVA_HOME，打开JAVA_HOME行的注释并修改 1export JAVA_HOME=/usr/java/jdk1.8.0_172-amd64/ 保存退出 保存数据的目录配置： 1vim hbase-2.0.1/conf/hbase-site.xml 在configuration标签中添加： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;file:///root/hbase/data/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/root/hbase/data/zookeeper&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 验证启动Hbase 1/root/hbase/hbase-2.0.1/bin/start-hbase.sh 没有报错即配置OK 安装Phoenix 将文件解压到目录：/root/phoenix 1tar zxfv apache-phoenix-5.0.0-alpha-HBase-2.0-bin.tar.gz 拷贝phoenix-5.0.0-alpha-HBase-2.0-server.jar到Hbase下lib目录中 1cp /root/phoenix/phoenix-5.0.0-alpha-HBase-2.0-server.jar /root/hbase/hbase-2.0.1/lib/ 验证重启Hbase 12# /root/hbase/hbase-2.0.1/bin/stop-hbase.sh# /root/hbase/hbase-2.0.1/bin/start-hbase.sh 重启成功后，启动Phoenix 1/root/phoenix/bin/sqlline.py localhost 当出现版本号sqlline version 1.2.0说明启动成功 12345678...Building list of tables and columns for tab-completion (set fastconnect to true to skip)...92/92 (100%) DoneDonesqlline version 1.2.00: jdbc:phoenix:localhost&gt; 使用Phoenix 使用!table命令 1234567890: jdbc:phoenix:localhost&gt; !table+------------+--------------+-------------+---------------+----------+------------+----------------------------+-----------------+--------------+-----------------+---------------+-+| TABLE_CAT | TABLE_SCHEM | TABLE_NAME | TABLE_TYPE | REMARKS | TYPE_NAME | SELF_REFERENCING_COL_NAME | REF_GENERATION | INDEX_STATE | IMMUTABLE_ROWS | SALT_BUCKETS | |+------------+--------------+-------------+---------------+----------+------------+----------------------------+-----------------+--------------+-----------------+---------------+-+| | SYSTEM | CATALOG | SYSTEM TABLE | | | | | | false | null | || | SYSTEM | FUNCTION | SYSTEM TABLE | | | | | | false | null | || | SYSTEM | SEQUENCE | SYSTEM TABLE | | | | | | false | null | || | SYSTEM | STATS | SYSTEM TABLE | | | | | | false | null | |+------------+--------------+-------------+---------------+----------+------------+----------------------------+-----------------+--------------+-----------------+---------------+-+]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
        <tag>Phoenix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust线程]]></title>
    <url>%2F2018%2F06%2F12%2Frust-thread%2F</url>
    <content type="text"><![CDATA[现在是越来越喜欢Rust了，敲了很多PHP代码，然而对多线程的了解却少之又少。 Rust并发为什么可以做的好？摘自官方文档的说明： Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety and concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you’re working on it rather than potentially after it has been shipped to production. We’ve nicknamed this aspect of Rust fearless concurrency. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs. 重点是这句： ownership and type systems are a powerful set of tools to help manage memory safety and concurrency problems 所有权和类型系统的设计解决了内存安全和并发问题。 线程小试使用spawn创建新线程 例子000： 12345678910111213141516use std::thread;use std::time::Duration;fn main() &#123; thread::spawn(|| &#123; for i in 1..10 &#123; println!("hi number &#123;&#125; from the spawned thread!", i); thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!("hi number &#123;&#125; from the main thread!", i); thread::sleep(Duration::from_millis(1)); &#125;&#125; 主线程只循环次数低于新线程，所以主线程结束后新线程随即也会结束。 结果： 12345678hi number 1 from the main thread!hi number 1 from the spawned thread!hi number 2 from the spawned thread!hi number 2 from the main thread!hi number 3 from the spawned thread!hi number 3 from the main thread!hi number 4 from the main thread!hi number 4 from the spawned thread! 由于新线程需要系统的调度，并不能确保执行顺序一致，那么如何保证数据的安全性不被更改呢？后面我们将使用lock的方式进行保证。 使用join等待所有线程结束由于主线程结束，示例000中的代码大部分时候不光会提早结束新建线程，甚至不能实际保证新建线程会被执行。其原因在于无法保证线程运行的顺序！thread::spawn返回值类型是JoinHandle，是一个拥有所有权的值，当对其调用join方法是，它会等待其线程结束。 例子：001123456789101112131415161718use std::thread;use std::time::Duration;fn main() &#123; let handle = thread::spawn(|| &#123; for i in 1..10 &#123; println!("hi number &#123;&#125; from the spawned thread!", i); thread::sleep(Duration::from_millis(1)); &#125; &#125;); for i in 1..5 &#123; println!("hi number &#123;&#125; from the main thread!", i); thread::sleep(Duration::from_millis(1)); &#125; handle.join().unwrap();&#125; 通过调用handle的join会阻塞当前线程直到handle所代表的线程结束。 结果：12345678910111213hi number 1 from the main thread!hi number 1 from the spawned thread!hi number 2 from the main thread!hi number 2 from the spawned thread!hi number 3 from the main thread!hi number 3 from the spawned thread!hi number 4 from the main thread!hi number 4 from the spawned thread!hi number 5 from the spawned thread!hi number 6 from the spawned thread!hi number 7 from the spawned thread!hi number 8 from the spawned thread!hi number 9 from the spawned thread! 如果把handle.join().unwrap()放到主线程之前会发生什么？ 结果：12345678910111213hi number 1 from the spawned thread!hi number 2 from the spawned thread!hi number 3 from the spawned thread!hi number 4 from the spawned thread!hi number 5 from the spawned thread!hi number 6 from the spawned thread!hi number 7 from the spawned thread!hi number 8 from the spawned thread!hi number 9 from the spawned thread!hi number 1 from the main thread!hi number 2 from the main thread!hi number 3 from the main thread!hi number 4 from the main thread! 线程与move闭包move闭包与thread::spawn一起使用允许我们在一个线程中使用另一个线程的数据。move关键字可以强制闭包获取值的所有权，覆盖了rust默认保守的借用：其也不允许我们违反所有权规则。 列子：002 1234567891011use std::thread;fn main() &#123; let v = vec![1, 2, 3]; let handle = thread::spawn(move || &#123; println!("Here's a vector: &#123;:?&#125;", v); &#125;); handle.join().unwrap();&#125; 结果：1Here's a vector: [1, 2, 3]]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust学习笔记]]></title>
    <url>%2F2018%2F04%2F01%2Frust-study-notes%2F</url>
    <content type="text"><![CDATA[String 与 &amp;strString 是一个被拥有（owned）的在堆上分配的 UTF-8 的字节缓冲区。可变 String 可以被修改，根据需要增加其容量。 &amp;str 是一个指向分配在某处的 String的一个固定容量的「视图」。如果切片是在从 String 解引而来的，则通常是指向在堆上，如果是字符串字面值，则指向静态内存。 &amp;str 是一个由 Rust 语言实现的原生类型，而 String 则是由标准库实现的。 12let a = "hello world";let b = "ok!"; 字面的“字符串”是&amp;str。a、b都是&amp;str，不是String。对Rust而言，&amp;str更象一个固定的数组；String更象一个可变的数组。 转换类型 &amp;str =&gt; String 12345let c = a.to_string(); //方法一let c = String::from(a) //方法二let c = a.to_owned(); //方法三 String =&gt; &amp;str 123456789//方法一let e = &amp;String::from("hello world");//方法二let e_0 = String::from("hello world"); let e = e_0.as_str();//但不可直接let e =String::from("hello world").as_str(); String + &amp;str =&gt; String 123456//注意：第一个是`String`，后面可以接N个`&amp;str`let f = c + b;//或let f = c + b + e;//增加一个e也可以//或let g = c.clone() + b + e 12345678//当然，另外的方法是：push_str()let mut strs = "hello".to_string();strs.push_str(" world!"); // hello world!println!("state1 :&#123;:?&#125;", strs);let mut s = String::from("foo");s.push_str("bar"); //foobarprintln!("&#123;:?&#125;", s); 模式匹配两个数进行对比使用模式匹配，如果简单的使用if比较值是否相等，编译会认为不安全的代码 1234567891011121314151617181920use std::cmp::Ordering;fn main() &#123; let a1 = vec![121, 144, 19, 161, 19, 144, 19, 11]; let a2 = vec![11*1111]; let ret = comp(a1, a2); println!("&#123;:?&#125;", ret);&#125;fn comp(a: Vec&lt;i64&gt;, b: Vec&lt;i64&gt;) -&gt; bool &#123; for i in &amp;a &#123; for j in &amp;b &#123; match i.cmp(&amp;j) &#123; Ordering::Less =&gt; &#123;&#125;, Ordering::Greater =&gt; &#123;&#125;, Ordering::Equal =&gt; return true, &#125; &#125; &#125; return false;&#125; 迭代123456789101112131415161718192021fn main() &#123; let test_data1 = vec![1, 2, 3, 5]; println!("&#123;:?&#125;", count_positives_sum_negatives(test_data1));&#125;fn count_positives_sum_negatives(input: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123; if input.is_empty() &#123; return vec![]; &#125; //`into_iter` 和 `iter`的区别，`iter`需要传引用 input.into_iter().fold(vec![0, 0], |mut acc, x| &#123; if x &gt; 0 &#123; acc[0] += 1; &#125; else &#123; acc[1] += x; &#125; acc &#125;)&#125; 类型转换123456789fn main() &#123; println!("&#123;:?&#125;", get_age(""));&#125;fn get_age(age: &amp;str) -&gt; u32 &#123; //age.chars().next().unwrap().to_digit(10).unwrap() let (a, _) = age.split_at(1); a.parse::&lt;u32&gt;().unwrap()&#125; 结构体结构体（structure，缩写成 struct）有 3 种类型，使用 struct 关键字来创建： 元组结构体，总的来说是根据元组来命名。 C 语言风格的结构体 c_struct。 单元结构体，不带字段，在泛型中很有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//单元结构体struct Nil;//元组结构体struct Pair(i32, f32);//带有两个字段的结构体struct Point &#123; x: f32, y: f32,&#125;//结构体可以作为另一个结构体的字段#[allow(dead_code)] //隐藏未使用代码警告的属性struct Rectangle &#123; p1: Point, p2: Point,&#125;//实例化结构体let point: Point = Point &#123;x: 0.3, y: 0.4&#125;;//访问结构体字段println!("&#123;&#125;, &#123;&#125;", point.x, point.y);//使用`let` 绑定来结构pointlet Point &#123;x: my_x, y: my_y&#125; = point;let _rectangle = Rectangle &#123; p1: Point &#123;x: my_x, y: my_y&#125;, p2: point,&#125;;//实例化一个单元结构体let _nil = Nil;//实例化一个元组结构体let pair = Pair(1, 0.1);// 访问元组结构体的字段println!("pair contains &#123;:?&#125; and &#123;:?&#125;", pair.0, pair.1);// 解构一个元组结构体let Pair(integer, decimal) = pair;println!("pair contains &#123;:?&#125; and &#123;:?&#125;", integer, decimal); 枚举The enum keyword allows the creation of a type which may be one of a few different variants. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 隐藏未使用代码警告的属性。#![allow(dead_code)]// 创建一个 `enum` （枚举）来划分人的类别。注意命名和类型的信息是如何一起// 明确规定变量的：// `Engineer != Scientist` 和 `Height(i32) != Weight(i32)`。每者都不相同且// 相互独立。enum Person &#123; // 一个 `enum` 可能是个 `unit-like`（类单元结构体）， Engineer, Scientist, // 或像一个元组结构体， Height(i32), Weight(i32), // 或像一个普通的结构体。 Info &#123; name: String, height: i32 &#125;&#125;// 此函数将一个 `Person` enum 作为参数，无返回值。fn inspect(p: Person) &#123; // `enum` 的使用必须覆盖所有情形（无可辩驳的），所以使用 `match` // 以分支方式覆盖所有类型。 match p &#123; Person::Engineer =&gt; println!("Is engineer!"), Person::Scientist =&gt; println!("Is scientist!"), // 从 `enum` 内部解构 `i` Person::Height(i) =&gt; println!("Has a height of &#123;&#125;.", i), Person::Weight(i) =&gt; println!("Has a weight of &#123;&#125;.", i), // 将 `Info` 解构成 `name` 和 `height`。 Person::Info &#123; name, height &#125; =&gt; &#123; println!("&#123;&#125; is &#123;&#125; tall!", name, height); &#125;, &#125;&#125;fn main() &#123; let person = Person::Height(18); let amira = Person::Weight(10); // `to_owned()` 从一个字符串 slice 创建一个具有所有权的 `String`。 let dave = Person::Info &#123; name: "Dave".to_owned(), height: 72 &#125;; let rebecca = Person::Scientist; let rohan = Person::Engineer; inspect(person); inspect(amira); inspect(dave); inspect(rebecca); inspect(rohan);&#125; 使用 use 声明，这样就不必手动加上作用域了 123456789101112131415161718192021222324252627282930313233343536// 隐藏未使用代码警告的属性。#![allow(dead_code)]enum Status &#123; Rich, Poor,&#125;enum Work &#123; Civilian, Soldier,&#125;fn main() &#123; // 明确地 `use` 各个名称使他们直接可用而不需要手动加上作用域。 use Status::&#123;Poor, Rich&#125;; // 自动地 `use` `Work` 内部的各个名称。 use Work::*; // 等价于 `Status::Poor`。 let status = Poor; // 等价于 `Work::Civilian`。 let work = Civilian; match status &#123; // 注意这里少了作用域，因为上面显式地使用了 `use`。 Rich =&gt; println!("The rich have lots of money!"), Poor =&gt; println!("The poor have no money..."), &#125; match work &#123; // 再次注意到这里没有作用域。 Civilian =&gt; println!("Civilians work!"), Soldier =&gt; println!("Soldiers fight!"), &#125;&#125; #[allow(non_camel_case_types)] #![allow(dead_code)] #![allow(unreachable_code)]]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust交互命令行源码分析]]></title>
    <url>%2F2018%2F03%2F31%2Frust-interactive-commanc-line%2F</url>
    <content type="text"><![CDATA[前景介绍有一项目是提供一个命令行式的对数据库进行CRUD、用户登录、操作日志记录等需求。刚好最近在研究rust，就找些lib进行开发，由于对rust不是很熟悉，先从研究别人的源码进行学习是我一贯的作风。 项目地址：GitHub 源码分析 自定义错误类型枚举 1234567891011121314151617181920212223242526272829303132333435use std::fmt;use std::error::Error;#[derive(Debug)]pub enum ExecError &#123; Empty, Quit, MissingArgs, UnknownCommand(String), InvalidHistory(usize), Other(Box&lt;Error&gt;),&#125;use ExecError::*;impl fmt::Display for ExecError &#123; fn fmt(&amp;self, format: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; match self &#123; &amp;Empty =&gt; write!(format, "No command provided"), &amp;Quit =&gt; write!(format, "Quit"), &amp;UnknownCommand(ref cmd) =&gt; write!(format, "Unknown Command &#123;&#125;", cmd), &amp;InvalidHistory(i) =&gt; write!(format, "Invalid history entry &#123;&#125;", i), &amp;MissingArgs =&gt; write!(format, "Not enough arguments"), &amp;Other(ref e) =&gt; write!(format, "&#123;&#125;", e) &#125; &#125;&#125;fn main() &#123; let error = ExecError::Empty; println!("&#123;:?&#125;", format!("&#123;&#125;", error)); let cmd = "Hello".to_string(); let error = ExecError::UnknownCommand(cmd); println!("&#123;:?&#125;", format!("&#123;&#125;", error));&#125; 分析： Box&lt;Error&gt; 使用智能指针，类型是Error。Box允许你将值放在堆上而不是栈上。 ref Wraps a borrowed reference to a value in a RefCell box. A wrapper type for an immutably borrowed value from a RefCell&lt;T&gt; 从一个不可变的RefCell中借来的引用存放在RefCell中，产生一个新的 RefCell]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust References]]></title>
    <url>%2F2018%2F01%2F30%2Frust-references%2F</url>
    <content type="text"><![CDATA[对于Ownership的手动归还，非常不方便，Rust允许使用reference来解决这个问题。 1234567891011fn main() &#123; let s1 = String::from("hello"); let len = calculate_length(&amp;s1); println!("The length of '&#123;&#125;' is &#123;&#125;.", s1, len);&#125;fn calculate_length(s: &amp;String) -&gt; usize &#123; s.len()&#125; reference是什么？borrow借，就是所有权没有改变，只是借用一下。可以比喻成我有一本书，这本书我拥有所有权你借用我的书，我给我允许你在书上写写画画，你才能写写画画。当你使用完毕，必须归还。 可变引用(我允许你更改) 123456789fn main() &#123; let mut s = String::from("hello"); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(", world");&#125; 可变引用是有很多限制的(我把书借给你，不能同时有多个人写写画画) 1234let mut s = String::from("hello");let r1 = &amp;mut s;let r2 = &amp;mut s; 报错： 123456789error[E0499]: cannot borrow `s` as mutable more than once at a time --&gt; borrow_twice.rs:5:19 |4 | let r1 = &amp;mut s; | - first mutable borrow occurs here5 | let r2 = &amp;mut s; | ^ second mutable borrow occurs here6 | &#125; | - first borrow ends here 这时候产生了数据竞争，是Rust的一种限制。 所有的引用的作用域必须小于所有者(owner)的作用域 你可以有多个不可变的引用(&amp;T)，但 同时只能有一个可变的引用(&amp;mut T) 不能同时有可变引用和不可变引用 可以使用作用域来允许拥护多个可变引用： 12345678let mut s = String::from("hello");&#123; let r1 = &amp;mut s;&#125; // r1 goes out of scope here, so we can make a new reference with no problems.let r2 = &amp;mut s; 对于下面这个引用，rust是不能编译通过的。 12345let mut s = String::from("hello");let r1 = &amp;s; // no problemlet r2 = &amp;s; // no problemlet r3 = &amp;mut s; // BIG PROBLEM 报错： 1234567891011error[E0502]: cannot borrow `s` as mutable because it is also borrowed asimmutable --&gt; borrow_thrice.rs:6:19 |4 | let r1 = &amp;s; // no problem | - immutable borrow occurs here5 | let r2 = &amp;s; // no problem6 | let r3 = &amp;mut s; // BIG PROBLEM | ^ mutable borrow occurs here7 | &#125; | - immutable borrow ends here 为什么？我们不能在拥有不可变的引用同时拥有可变引用。 我把书借给A，A看着看着内容变了，这个时候谁能忍！！！！rust语言闪光点之一就是这个reference]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rust Ownership]]></title>
    <url>%2F2018%2F01%2F29%2Frust-ownership%2F</url>
    <content type="text"><![CDATA[Rust的Ownership是区别其他语言的最主要的特征，虽然有点绕，但是从简入深是我一贯的学习方法。 Rust绑定变量有一个特征：获得它所绑定资源的所有权。意味着当绑定变量超出作用域时，它所绑定资源的资源就会被释放。 1234let s1 = String::from("hello");let s2 = s1;println!("&#123;&#125;, world!", s1); 编译时会报错： 1234567891011error[E0382]: use of moved value: `s1` --&gt; src/main.rs:5:28 |3 | let s2 = s1; | -- value moved here4 |5 | println!("&#123;&#125;, world!", s1); | ^^ value used here after move | = note: move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait 因为把s1赋给s2，他们都指向了同一个String，所有权移交给了s2再去使用s1就违反了rust的安全。如果想使用s1可以使用clone 1234let s1 = String::from("hello");let s2 = s1.clone();println!("s1 = &#123;&#125;, s2 = &#123;&#125;", s1, s2); 下面这段代码可以正常执行： 1234let x = 5;let y = x;println!("x = &#123;&#125;, y = &#123;&#125;", x, y); 原因是在编译时对于已知大小的整数类型完全存储在堆栈中，因此对实际值的clone会很快完成，使用深度或浅度的clone并没有不同。 以下类型是Copy： 所有的整型。如：u32 布尔类型。 字符串类型。 浮点类型。 元组类型，但仅仅是相同的类型。如：(i32, i32)，而(i32, String)并不会Copy 对于函数的调用进行Ownership，也是大同小异。 1234567891011fn main () &#123; let s = String::from("Hello"); takes_ownership(s); println!("s is &#123;&#125;", s);&#125;fn takes_ownership(some_string: String) &#123; println!("some_string value is &#123;&#125;", some_string);&#125; 编译时将会报错，因为s的所有权移交给了函数takes_ownership。 123456789 --&gt; src/main.rs:6:28 |4 | takes_ownership(s); // s's value moves into the function... | - value moved here5 | // ... and so is no longer valid here.6 | println!("s value &#123;&#125;", s); | ^ value used here after move | = note: move occurs because `s` has type `std::string::String`, which does not implement the `Copy` trait 如果想让s在main函数中正常访问，只需让takes_ownership函数返回值即可。 12345678910111213fn main () &#123; let s = String::from("Hello"); let s = takes_ownership(s); println!("s is &#123;&#125;", s);&#125;fn takes_ownership(some_string: String) -&gt; String &#123; println!("some_string value is &#123;&#125;", some_string); let some_string = some_string; some_string&#125; 或者使用References 12345678910fn main() &#123; let s = String::from("Hello"); let len = string_len(&amp;s); println!("The length of '&#123;&#125;' is &#123;&#125;.", s, len);&#125;fn string_len(s: &amp;String) -&gt; usize &#123; s.len()&#125;]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2018%2F01%2F15%2Fpython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为什么小时候感觉一年的时间很长，现在却越来越短？是不是对这个世界了解的越多，人生越短暂？ 什么是装饰器如果我们需要对一个函数在调用前后自动打印日志，但又不希望修改现有函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”。 装饰器本质上就是一个函数，只是python对它进行了简化，形成的现今的语法糖模式，装饰器的返回值也是一个函数对象。装饰器的作用就是为了已经存在的函数或对象添加额外的功能。 下面开始举栗子：如果我们执行foo函数时，需要记录日志。12def foo(): print('function is foo') 不用装饰器的模式，我们需要这样写：123def foo(): print('function is foo') log.debug('foo') 为什么需要装饰器装饰器可以简化代码复杂度，可以抽离大量与函数功能本身无关的雷同的代码并继续重用。举个栗子：在接口调用时进行权限校验，如果没有权限抛出异常，有权限则继续进行。 1234567891011121314def permission(func): def check(id): if (id == 100): print("permission denied") return False return func(id) return check@permissiondef user_info(user_id): print("hello &#123;&#125;!".format(user_id))if __name__=='__main__': user_info(100) 说明：相当于之前的版本实现：permission(user_info)(100)装饰器函数permission把函数user_info 传入，func 就相当于user_info然后在return check 时调用check函数 实现高级点的装饰器带参数的装饰器 12345678910111213141516171819202122def log(level): def wrapper(func): def inner_wrapper(*args, **kwargs): print('[&#123;level&#125;]：enter function &#123;func&#125;()'.format( level = level, func = func.__name__)) return func(*args, **kwargs) return inner_wrapper return wrapper@log(level = 'DEBUG')def create(): print("create data")@log(level = 'INFO')def find(): print("find data")if __name__ == '__main__': create() find() 基于类实现的装饰器123456789101112131415161718192021class log(object): def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): print("[DEBUG]：enter function &#123;func&#125;()".format( func = self.func.__name__))@logdef create(): print("create data")@logdef find(): print("find data")if __name__ == '__main__': create() find() 使用__call__这样的python内置方法，和PHP中的call方法的功能一样，进行方法的重载并返回一个函数，也可以达到装饰器函数的效果。 带参数的类装饰器123456789101112131415161718192021222324class log(object): def __init__(self, level = 'INFO'): self.level = level def __call__(self, func): def warpper(*args, **kwargs): print("[&#123;level&#125;]：enter function &#123;func&#125;()".format( func = func.__name__, level = self.level)) func(*args, **kwargs) return warpper@log(level='INFO')def create(): print("create data")@log(level='INFO')def find(level='INFO'): print("find data")if __name__ == '__main__': create() find() 内置装饰器内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象。 @propertyproperty()函数的作用是在新式类中返回属性值。 1class property([fget[, fset[, fdel[, doc]]]]) 参数 fget — 获取属性值的函数 fset — 设置属性值的函数 fdel — 删除属性值函数 doc — 属性描述信息 返回值 返回新式类属性。 实例 1234567891011121314151617class C(object): def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, "I'm the 'x' property.")c = C()print(c.getx()) @staticmethod, @classmethod一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。@staticmethod返回的是一个staticmethod类对象，而@classmethod返回的是一个classmethod类对象。他们都是调用的是各自的init()构造函数。 @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。 @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。 1234567891011121314151617181920212223class A(object): bar = 1 def foo(self): print 'foo' @staticmethod def static_foo(): print 'static_foo' print A.bar @classmethod def class_foo(cls): print 'class_foo' print cls.bar cls().foo()# 对类进行实例化再进行调用类的方法#A().static_foo()#A().class_foo()# 实现了装饰，不需要进行类的实例化A.static_foo()A.class_foo()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim使用记录]]></title>
    <url>%2F2017%2F12%2F18%2Fvim-study-notes%2F</url>
    <content type="text"><![CDATA[使用的插件及配置github：https://github.com/spf13/spf13-vim 命令小记:args 查看已打开的文件列 :hide edit foo.txt 不保存，隐藏当前的文件，编辑foo.txt :wnext 保存当前，并进入下一个文件 :wprevious 保存当前，并进入上一个文件 :last 移动到列表最后一个 :first 移动到列表第一个 :vertical diffsplit FILE_RIGHT对比文件 `“ 跳到上次离开这个文件的位置 `. 跳到这个文件最后一次修改的位置 mx 文件标记 50%mJ 在这个文件做一个标记，在其他地方可以使用 `{mark} 跳回到该位置，此时mark就是J :marks J 查看J标记在什么地方 :%s/allen/tony/g 全局替换，将文本中所有的 allen 替换为 tony 9y 拷贝第9行，不必移动光标 ggvG 全选文件内容 gg=G 格式化文件 = 格式化选定文本 vip 选取当前光标所在段落 &lt; 取消缩进文本 5&lt;&lt; 对5行文本取消缩进 :marks 查看所有书签 delm X 删除书签X :ls 查看缓冲区 :bN 打开缓冲区N vim -o *.php 打开当前目录下全部.php文件 :qa 退出全部窗口 :1?xxx / G?xxx 从文件末尾开始查找 J 合并行 gj / gk 对于换行的段落的行移动 :sh 暂时离开vi，进入shell :!ls !表示要执行一个shell命令 q: 调出历史命令窗口 cc 替换一行，清空一行 ew 替换一个单词，进入插入模式 ea 在当前单词最后插入 VU 全选一行，转换成大写 Vu 全选一行，转换成小写 :5,12 co 13 将5至12行复制到第13行下 % 匹配括号移动 * 和 # 匹配光标当前所在的单词，移动到下(上)一个匹配的单词 ,c&lt;空格&gt; 被选区域被注释，则取消，反之，注释 ,cc 注释当前行和选中行 插件使用 SESSION ,sl session list ,ss session save ,sc session close NERDTree ma 新建文件或目录 Bookmark]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python异常处理]]></title>
    <url>%2F2017%2F12%2F15%2Fpython%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近研究了下python的异常处理，现记录下。python的异常设计还是不错的。 常见异常 常见异常 解释 IOError 输入\输出异常；基本是无法打开文件 ImportError 无法引入模块或包；基本上是路径问题或名称错误 IndexError 下表索引超出序列边界 KeyError 试图访问字典里不存在的键 NameError 使用一个还未被赋予对象的变量 IndentationError 语法错误(的子类)；代码没有正确对齐 SyntaxError python代码非法，代码不能编译 KeyboardInterrupt Ctrl+C被按下 EOFError Ctrl+D被按下 UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另一个同名的全局变量，导致以为正在访问它 AttrbuteError 试图访问一个对象没有的属性 ValueError 传入一个调用者不期望的值，即使值的类型是正确的 TypeError 传入对象的类型与要求的不符合 异常的捕捉1234567try: a = [1, 2, 3] a[3]except IndexError: print('IndexError')finally: print('finally') except后面可以不再加异常也可加多个异常。 else: 没有发现异常是会执行finally: 无论是否发生异常都会执行 定制自己的异常虽然python内置的异常已经很多，但有时我们需要实现自己的异常功能。 12345678class HException(Exception): passtry: name = raw_input(&apos;name:&apos;).strip() if name != &apos;han&apos;: raise HExceptionexcept HException: print(&apos;No valid name sepecfied...&apos;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <url>%2F2017%2F12%2F15%2Fc-gdb%2F</url>
    <content type="text"><![CDATA[最近研究Redis源码，对C语言也重温了下。小时候老爷子总和我说：三天不学习，赶不上刘少奇。我这C语言都不知还能赶上谁，不过刘少奇我应该能赶上，因为他不懂。 由于Mac平台没有安装GDB，安装步骤及方法网上教程很多，就不赘述了，记得重启taskgated进程。 待调式的代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;int *uninit;int *nullptr = NULL;void *vptr;int val = 1;int *iptr;int *castptr;void sayHello();void sayHello()&#123; printf("hello world\n");&#125;int main()&#123; iptr = &amp;val; vptr = iptr; printf("iptr=%p, vptr=%p\n", iptr, vptr); castptr = vptr; printf("*castptr=%d\n", *castptr); int myarray[4] = &#123;1, 2, 3, 0&#125;; int *han = myarray; int *han0 = &amp;myarray[0]; int *han1 = &amp;myarray[1]; printf("*han=%d\n", *han); printf("*han0=%d\n", *han0); printf("*han1=%d\n", *han1); struct person &#123; int age; char *name; &#125;; struct person first; struct person *yan; first.age = 21; char *fullname = "yanyan"; first.name = fullname; yan = &amp;first; printf("age=%d, name=%s\n", first.age, yan-&gt;name); printf("age=%d, name=%s\n", yan-&gt;age, yan-&gt;name); sayHello(); void (*sayHelloPtr)() = sayHello; sayHelloPtr(); (*sayHelloPtr)();&#125; 编译1~/Sites/c_study gcc -g main.c -o main 进入调式12~/Sites/c_study gdb main(gdb) 命令介绍 r Run的简写，运行被调式的程序，如果没有断点执行完整程序；有断点则执行到断点处停止 b Breakpoint的简写，设置断点。可以使用行号、函数名、地址等方式设置断点位置。b &lt;行号&gt;,b &lt;函数名&gt;,b *&lt;函数名&gt;,b *&lt;代码地址&gt;, d Delete Breakpoint的简写，删除某个断点或所有断点。 s, n s 执行一行源码，如果此行有函数，则进入该函数n 执行一行源码，此行代码中的函数调用也一并执行。 p Print的简写，显示指定变量的值。 l List的简写，显示待调试的源文件代码 q Quit的简写，退出GDB调试环境 调式目标 18行变量iptr和val的值 25行han和myarray的值 36行first的结构信息 38行的first 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(gdb) b 18Breakpoint 6 at 0x100000db5: file main.c, line 18.(gdb) b 25Breakpoint 7 at 0x100000e16: file main.c, line 25.(gdb) b 26Breakpoint 8 at 0x100000e1a: file main.c, line 26.(gdb) b 38Breakpoint 9 at 0x100000e76: file main.c, line 38.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /Users/hg/Sites/c_study/main[New Thread 0x1c03 of process 2071]warning: unhandled dyld version (15)Thread 2 hit Breakpoint 6, main () at main.c:1818 iptr = &amp;val;(gdb) p iptr$32 = (int *) 0x0(gdb) p val$33 = 1(gdb) n19 vptr = iptr;(gdb) p iptr$34 = (int *) 0x100001028 &lt;val&gt;(gdb) p val$35 = 1(gdb) n20 printf("iptr=%p, vptr=%p\n", iptr, vptr);(gdb) niptr=0x100001028, vptr=0x10000102821 castptr = vptr;(gdb) n22 printf("*castptr=%d\n", *castptr);(gdb) n*castptr=124 int myarray[4] = &#123;1, 2, 3, 0&#125;;(gdb) nThread 2 hit Breakpoint 7, main () at main.c:2525 int *han = myarray;(gdb) p han$36 = (int *) 0x0(gdb) p myarray$37 = &#123;1, 2, 3, 0&#125;(gdb) nThread 2 hit Breakpoint 8, main () at main.c:2626 int *han0 = &amp;myarray[0];(gdb) n27 int *han1 = &amp;myarray[1];(gdb) n28 printf("*han=%d\n", *han);(gdb) n*han=129 printf("*han0=%d\n", *han0);(gdb) n*han0=130 printf("*han1=%d\n", *han1);(gdb) n*han1=2Thread 2 hit Breakpoint 9, main () at main.c:3838 first.age = 21;(gdb) p first$38 = &#123;age = 0, name = 0x100003248 "\031"&#125;(gdb) n39 char *fullname = "yanyan";(gdb) p first$39 = &#123;age = 21, name = 0x100003248 "\031"&#125;(gdb)]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件处理杂记]]></title>
    <url>%2F2017%2F11%2F21%2Flinux-file-command%2F</url>
    <content type="text"><![CDATA[取前30行 1head -n 30 sort_chat_num_1027_before.csv &gt; top30_before.csv 文件按第三列排序 123456789101112131415//源文件~/Desktop cat 1027_later.csv | more2017-10-27, 1900086667, 32017-10-27, 1900088305, 02017-10-29, 1900092050, 12017-11-01, 1900101877, 02017-11-01, 1900102164, 02017-11-01, 1900102646, 02017-11-03, 1900105446, 32017-11-03, 1900106760, 102017-11-04, 1900108652, 02017-11-04, 1900108943, 3... 1sort -t ',' -k 3 -nr 1027_later.csv &gt; sort_chat_num_1027_later.csv]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis源码-简单字符串SDS]]></title>
    <url>%2F2017%2F11%2F05%2Fredis-simple-dynamic-string%2F</url>
    <content type="text"><![CDATA[结构体定义123456789101112131415161718struct sdshdr &#123; //记录buf中已占用空间的长度 //5 表示这个sds保存了一个五字节长的字符串 int len; // 记录buf中剩余可用空间的长度 //0 表示这个sds没有分配任何未使用的空间 int free; // 数据空间 //redis字符串在buf中是一个数组,[&apos;r&apos;,&apos;e&apos;,&apos;d&apos;,&apos;i&apos;,&apos;s&apos;] //最后一位&apos;\0&apos;是空字符，不记在len中 char buf[];&#125;; SDS与C字符串实现的区别记录字符长度常规C字符串不记录字符串本身长度，所以取C中的字符串必须遍历整个字符串，操作复杂度为O(N)。 而SDS实现了字符串长度记录，可直接读取len，操作复杂度为O(1)。确保了redis获得长度而成为redis性能瓶颈。 杜绝了缓冲区溢出因为C不记录字符串长度，所以进程字符串复制、修改时，如果内存分配失误，便有可能产生缓冲溢出。 1234//追加字符串t到s的尾部sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125; 1234567891011121314151617181920212223242526272829sds sdscatlen(sds s, const void *t, size_t len) &#123; struct sdshdr *sh; // 原有字符串长度 size_t curlen = sdslen(s); // 扩展 sds 空间 // T = O(N) s = sdsMakeRoomFor(s,len); // 内存不足？直接返回 if (s == NULL) return NULL; // 复制 t 中的内容到字符串后部 // T = O(N) sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); // 更新属性 sh-&gt;len = curlen+len; sh-&gt;free = sh-&gt;free-len; // 添加新结尾符号 s[curlen+len] = &apos;\0&apos;; // 返回新 sds return s;&#125; 123456789101112131415161718192021222324252627282930313233343536373839sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // 获取 s 目前的空余空间长度 size_t free = sdsavail(s); size_t len, newlen; // s 目前的空余空间已经足够，无须再进行扩展，直接返回 if (free &gt;= addlen) return s; // 获取 s 目前已占用空间的长度 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s 最少需要的长度 newlen = (len+addlen); // 根据新长度，为 s 分配新空间所需的大小 if (newlen &lt; SDS_MAX_PREALLOC) // 如果新长度小于 SDS_MAX_PREALLOC // 那么为它分配两倍于所需长度的空间 newlen *= 2; else // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // 内存不足，分配失败，返回 if (newsh == NULL) return NULL; // 更新 sds 的空余长度 newsh-&gt;free = newlen - len; // 返回 sds return newsh-&gt;buf;&#125; 编译测试根据sds.c的定义即可知道12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#include &lt;assert.h&gt;#include &quot;sds.h&quot;#include &quot;zmalloc.h&quot;...#ifdef SDS_TEST_MAIN#include &lt;stdio.h&gt;#include &quot;testhelp.h&quot;#include &quot;limits.h&quot;int main(void) &#123; ...&#125;... 使用gcc编译1234# 直接编译gcc zmalloc.c testhelp.h sds.c -D SDS_TEST_MAIN# gdb编译gcc -g zmalloc.c testhelp.h sds.c -D SDS_TEST_MAIN 运行a.out 1234567891011121314151617181920212223242526~/Sites/redis-3.0-annotated/src(unstable ✗) ./a.out1 - Create a string and obtain the length: PASSED2 - Create a string with specified length: PASSED3 - Strings concatenation: PASSED4 - sdscpy() against an originally longer string: PASSED5 - sdscpy() against an originally shorter string: PASSED6 - sdscatprintf() seems working in the base case: PASSED7 - sdscatfmt() seems working in the base case: PASSED8 - sdscatfmt() seems working with unsigned numbers: PASSED9 - sdstrim() correctly trims characters: PASSED10 - sdsrange(...,1,1): PASSED11 - sdsrange(...,1,-1): PASSED12 - sdsrange(...,-2,-1): PASSED13 - sdsrange(...,2,1): PASSED14 - sdsrange(...,1,100): PASSED15 - sdsrange(...,100,100): PASSED16 - sdscmp(foo,foa): PASSED17 - sdscmp(bar,bar): PASSED18 - sdscmp(bar,bar): PASSED19 - sdscatrepr(...data...): PASSED20 - sdsnew() free/len buffers: PASSED21 - sdsMakeRoomFor(): PASSED22 - sdsIncrLen() -- content: PASSED23 - sdsIncrLen() -- len: PASSED24 - sdsIncrLen() -- free: PASSED25 tests, 24 passed, 0 failed]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis源码-跳跃表]]></title>
    <url>%2F2017%2F11%2F02%2Fredis-skip-list%2F</url>
    <content type="text"><![CDATA[跳跃表简介跳跃表是一种随机化数据结构，基于并联的链表，其效率可以比拟平衡二叉树，查找、删除、插入等操作都可以在对数期望期间内完成，对比平衡树，跳跃表的实现要简单直观。 Redis中跳跃表的数据结构Redis作者为了适合自己功能的需要，对原来的跳跃表进行修改： * 允许重复的score值，即多个不同的元素的score值可以相同 * 进行元素对比的时候，不仅要检查score值，还需要检查元素，当score的值相等，比较元素 * 结构保存一个tail指针，跳跃表的表尾指针 * 每个节点都有一个高度为1层的前驱指针，用于从底层表尾向表头方向遍历跳跃表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 创建一个层数为 level 的跳跃表节点， * 并将节点的成员对象设置为 obj ，分值设置为 score 。 * * 返回值为新创建的跳跃表节点 * * T = O(1) */zskiplistNode *zslCreateNode(int level, double score, robj *obj) &#123; // 分配空间 zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel)); // 设置属性 zn-&gt;score = score; zn-&gt;obj = obj; return zn;&#125;/* * 创建并返回一个新的跳跃表 * * T = O(1) */zskiplist *zslCreate(void) &#123; int j; zskiplist *zsl; // 分配空间 zsl = zmalloc(sizeof(*zsl)); // 设置高度和起始层数 zsl-&gt;level = 1; zsl-&gt;length = 0; // 初始化表头节点 // T = O(1) zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL); for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123; zsl-&gt;header-&gt;level[j].forward = NULL; zsl-&gt;header-&gt;level[j].span = 0; &#125; zsl-&gt;header-&gt;backward = NULL; // 设置表尾 zsl-&gt;tail = NULL; return zsl;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Redis</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人工具一览表]]></title>
    <url>%2F2017%2F11%2F02%2F%E4%B8%AA%E4%BA%BA%E5%B7%A5%E5%85%B7%E4%B8%80%E8%A7%88%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[权当做个备份，哪天电脑挂了，脑袋抽筋了，来这里遛一遛补充下。 硬件 分类 用途 脑补 电脑(Mac Pro) 程序员的饭碗 键盘(雷柏 v500S) 16年双11入手的第一款机械键盘 鼠标(罗技 M185) 显示器(戴尔 U2518D) 耳机(BOSE QC35) YY在自己的世界里 笔(Pelikan M215 06年银环款) 码累了，和王羲之聊聊书法 眼药水 (Santen) 抗疲劳，谁用谁知道 软件 分类 用途 脑补 sublime Text iTerm2 Chrome 微信 PHPstorm 为知笔记 Pages Keynote Charles 抓包代理工具 Hammerspoon lua开发，定制快捷键等，开源、强大 MacVim Zeplin Adobe Photoshop cc Postman 用于调试接口 网易云音乐 Sequel Pro MySQL客户端 SourceTree Git GUI brew Mac中的神器 翻译(系统自带和Python脚本) python脚本是调用有道的api]]></content>
      <categories>
        <category>后花园</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux杂记]]></title>
    <url>%2F2017%2F10%2F30%2Flinux-study-notes%2F</url>
    <content type="text"><![CDATA[错误信息 12//将会返回上次的错误信息$ %boast 用户进程数限制 /etc/security/limits.conf 查看本机用户 /etc/passwd 12345678910//用户名:密码:UID:GID:用户全名:home目录:shellroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync... 查看本机用户组 /etc/group 12345678910111213141516//组名:用户组密码:GID:用户组内的用户名root:x:0:bin:x:1:bin,daemondaemon:x:2:bin,daemonsys:x:3:bin,admadm:x:4:adm,daemontty:x:5:disk:x:6:lp:x:7:daemonmem:x:8:kmem:x:9:wheel:x:10:mail:x:12:mail,postfix... 文件属性 1234567//d目录//rwx拥有者权限//r-x所属用户组权限//r-x其他权限//3 连接数//root root 拥有者 所属用户组drwxr-xr-x. 3 root root 4096 Sep 1 18:52 rust_study 连接数 Linux所使用的文件系统是一种基于iNode的文件系统，每一个新创建的文件都会被分配一个iNode，它指向的是文件所在磁盘中的物理位置。连接数其实就是iNode的引用计数。 负载分析 123uptimepidstat]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python虚拟环境创建]]></title>
    <url>%2F2017%2F10%2F28%2Fpython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Python虚拟环境是一个可以相互隔离的虚拟环境，所有的依赖都可以放在当前项目的虚拟环境中，这样可以进行多个Python项目的开发。 创建虚拟环境 1$ python3 -m venv .tensorflow # 在当前目录创建.tensorflow 激活虚拟环境 1$ source .tensorflow/bin/activate 退出虚拟环境 1$ deactivate venv的详细使用参数 1234567891011121314151617181920212223usage: venv [-h] [--system-site-packages] [--symlinks] [--clear] [--upgrade] [--without-pip] ENV_DIR [ENV_DIR ...]Creates virtual Python environments in one or more target directories.positional arguments: ENV_DIR A directory to create the environment in.optional arguments: -h, --help show this help message and exit --system-site-packages Give access to the global site-packages dir to the virtual environment. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the environment directory if it already exists. If not specified and the directory exists, an error is raised. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令-awk]]></title>
    <url>%2F2017%2F08%2F29%2Flinux-awk%2F</url>
    <content type="text"><![CDATA[前段时间导一些运营数据，使用awk进行了一些格式化处理、计算等，今天刚好有点空闲就记录巩固下 Help Help123456789[root@hg ~]# awk --help用法: awk [POSIX 或 GNU 风格选项] -f 脚本文件 [--] 文件 ...用法: awk [POSIX 或 GNU 风格选项] [--] '程序' 文件 ...gawk 是一个模式扫描及处理语言。缺省情况下它从标准输入读入并写至标准输出。范例: gawk '&#123; sum += $1 &#125;; END &#123; print sum &#125;' file gawk -F: '&#123; print $1 &#125;' /etc/passwd 敲一敲 瞧一瞧小试牛刀12345678910[root@hg ~]# awk '&#123;print $0&#125;' /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync... &#39;{....}&#39; 可执行的程序 $0 变量，标示当前行；$1，当前行第一列，$2，当前行第二列，依此类对 print 输出 分割符123456789101112[root@hg ~]# awk -F ':' '&#123;print $1&#125;' /etc/passwdrootbindaemonadmlpsyncshutdownhalt... awk内置变量的使用$0 表示文本处理时的当前行 $1 表示文本行被分割的第一个字段 $n 表示文本行被分割的第n个字段 NR 表示文件中的行号，表示当前是第几行 NF 表示文件中的当前行个数(列数) FS 表示awk的输入分隔符，默认分隔符为空格和制表符 OFS 表示awk的输出分隔符，默认为空格 FILENAME 表示当前文件的名称 赋值和运算1234~/Sites awk '&#123;print $0&#125;' 1.txthan 10 1991yan 10 1993jie 10 1993 把第三列使用”*“代替 1234~/Sites awk '&#123;print $1, $2, $3 ="***"&#125;' 1.txthan 10 ***yan 10 ***jie 10 *** 把第二列累加求和 12~/Sites awk '&#123;sum +=$2&#125;;END &#123;print sum&#125;' 1.txt30 把第一列为‘han’的行，第二列和第三列用“*”代替 1234~/Sites awk '$1 == "han" &#123;print $1, $2 = "***", $3 = "***"&#125; $1 != "han" &#123;print $0&#125;' 1.txthan *** ***yan 10 1993jie 10 1993 函数介绍 函数名 简介 gsub(r, s) 在整个$0中用s替代r gsub(r, s, t) 在整个t中用s替代r index(s, t) 返回s中字符串t的第一位置 length(s) 返回s长度 match(s, r) 测试s是否包含匹配r的字符串 split(s, a, fs) 在fs上将s分成序列a sprint(fmt, exp) 返回经fmt格式化后的exp sub(r, s) 用$0中最左边最长的子串代替s substr(s, p) 返回字符串s中从p开始的后缀部分 substr(s, p, n) 返回字符串s中从p开始长度为n的后缀部分 函数小试把文件中“3”替换成“*” 123~/Sites awk 'gsub("3", "*") &#123;print $0&#125;' 1.txtyan 10 199*jie 10 199* 查找包含“j”的行 12~/Sites awk '/j/ &#123;print $0&#125;' 1.txtjie 10 1993 分割 1~/Sites awk '&#123;print $1&#125;' | awk '&#123;split($0, a, ":"); print a[3]&#125;' 1.txt 去重 12//按第一列进行去重cat php_sort.log | awk '!a[$1]++&#123;print $0&#125;' &gt; php_uniq.log 加单引号 12//在第一列、第二列加单引号awk '&#123;print "\047" $1 "\047" "\047" $2 "\047"&#125;' file.csv 双引号替换成单引号 1awk 'gsub("\"", "\047") &#123;print $0&#125;' file.csv]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP源码学习-用户代码的执行]]></title>
    <url>%2F2017%2F07%2F02%2Fphp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[生命周期和Zend引擎一切的开始：SAPI接口SAPI指的PHP具体应用的编程接口，脚本执行的开始都是以SAPI接口实现开始的。 开始和结束PHP执行以后经过两个主要阶段：处理请求之前的开始阶段和请求之后的结束阶段。开始阶段有两个过程：第一过程是模块初始化阶段（MINIT），在整个SAPI生命周期内（例如Apache启动以后的整个生命周期内或命令行程序整个执行过程中），该过程只进行一次。第二个过程是模块激活阶段（RINIT），该过程发生在请求阶段，例如：通过URL请求某个页面，则在每次请求之前都会进行模块激活。例如：PHP注册了一些扩展模块，则在MINIT阶段会回调所有模块的MINIT函数。模块在这个阶段可以进行一些初试化工作，例如：注册常量、定义模块使用的类等。模块在实时可以通过如下宏来实现这些回调函数：12345PHP_MINIT_FUNCTION(myphpextension)&#123; // 注册常量或者类等初始化操作 return SUCCESS; &#125; 请求到达之后PHP初始化执行脚本的基本环境，例如：创建一个执行环境，包括保存PHP运行过程中变量名称和值内容的符号表、当前所有的函数以及类等信息的符号表。然后php会调用所有模块的RINIT函数，在这个阶段各个模块也可以执行一些相关的操作。123456PHP_RINIT_FUNCTION(myphpextension)&#123; // 例如记录请求开始时间 // 随后在请求结束的时候记录结束时间。这样我们就能够记录下处理请求所花费的时间了 return SUCCESS; &#125; 请求处理完后就进入了结束阶段，一般脚本执行到行尾或通过调用exit()或die()函数，PHP都将进入结束阶段。和开始阶段对应，结束阶段也分为两个环节：一个在请求结束后停用模块(RSHUTDOWN,对应RINIT)，一个在SAPI生命周期结束（web服务器退出或命令行脚本执行完毕退出）时关闭模块（MSHUTDOWN，对应MINIT）。12345PHP_RSHUTDOWN_FUNCTION(myphpextension)&#123; // 例如记录请求结束时间，并把相应的信息写入到日至文件中。 return SUCCESS; &#125; 单进程SAPI生命周期CLI/CGI模式的PHP属于单进程的SAPI模式。这类的请求处理一次请求后就关闭。 启动在调用每个模块的模块初始化前，会有一个初始化的过程，包括： 初始化若干全局变量在这里的初始化全局变量大多数情况下是将其设置为NULL，有些除外，比如设置zuf（zend_utility_functions）,以zuf.printf_function = php_printf为例，这里的php_printf在zend_startup函数中会被赋值给zend_printf作为全局函数指针使用，而zend_printf函数通常会作为常规字符串输出使用，比如显示程序调用栈的debug_print_backtrace就是使用它打印相关信息。 初始化若干常量这里的常量是PHP自己的一些常量，这些常量要么是硬编码在程序中，比如PHP_VERSION，要么是写在配置头文件中，比如PEAR_EXTENSION_DIR，这些是写在config.w32.h文件中。 初始化Zend引擎和核心组件前面提到的zend_startup函数的作用就是初始化zend引擎，这里的初始化操作包括内存管理初始化、全局使用的函数指针初始化（如前面所说的zend_printf等），对PHP源文件进行词法分析、语法分析、中间代码执行的函数指针的赋值，初始化若干hashTable（如函数表、常量表等），为ini文件解析做准备，为PHP源文件解析做准备，注册内置函数（如strlen、define等），注册标准常量（如E_ALL，TRUE，NULL等）、注册GLOBALS全局变量等。 解析php.iniphp_init_config函数的作用是读取php.ini文件，设置配置参数，加载zend扩展并注册PHP扩展函数。此函数分为以下几步：初始化参数配置表，调用当前模式下的ini初始化配置，如CLI模式下，会做如下初始化：12INI_DEFAULT("report_zend_debug", "0");INI_DEFAULT("display_errors", "1"); 不过在其他模式下却没有这样的初始化操作。接下来的各种操作都是查找ini文件： 判断是否有php_ini_path_override，在CLI模式下可以通过-c参数指定此路径（在php的命令参数中-c表示在指定路径中查找ini文件）。 如果没有php_ini_path_override，判断php_ini_ignore是否为空（忽略php.ini配置，这里也就CLI模式下有用，使用-n参数）。 如果不忽略ini配置，则开始处理php_ini_search_path（查找ini文件的路径），这些路径包括CWD（当前路径，不过这种不适用CLI模式）、执行脚本所在目录、环境变量PATH和PHPRC和配置文件中的PHP_CONFIG_FILE_PAYH的值。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP源码学习-常用代码]]></title>
    <url>%2F2017%2F06%2F30%2Fphp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[双井号(##)##被称为连接符，是一种预处理运算符，用来把两个语言符号组合成单个语言符号。这里的语言符号不一定是宏的变量。且双井号不能作为第一个或最后一个元素存在123456789101112#define PHP_FUNCTION ZEND_FUNCTION#define ZEND_FUNCTION(name) ZEND_NAMED_FUNCTION(ZEND_FN(name))#define ZEND_FN(name) zif_##name#define ZEND_NAMED_FUNCTION(name) void name(INTERNAL_FUNCTION_PARAMETERS)#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \zval *this_ptr, int return_value_used TSRMLS_DC PHP_FUNCTION(count); // 预处理器处理以后， PHP_FUCNTION(count);就展开为如下代码void zif_count(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC) 宏ZEND_FN(name)中有一个##，它的作用是一个连接符，将zif和宏的变量name的值连接起来。以这种连接的方式为基础，多次用用这种宏形式，可以将它作为一个代码生成器，这样在一定程度上减少代码密度，可以理解为一种代码重用的手段，间接地减少错误。 单井号(#)#是一种预处理运算符，它的功能是将其后面的宏参数字符串化操作，简单的说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号，官方说法是将语言符号(Token)转化为字符串。1234567#define STR(x) #x int main(int argc char** argv)&#123; printf("%s\n", STR(It's a long string)); // 输出 It's a long string return 0;&#125; #line预处理1#line 838 "Zend/zend_language_scanner.c" #line预处理用于改变当前的行号(LINE)和文件名(FILE)。编译器对C源码编译过程中会产生一些中间文件，通过这条指令，可以保证文件名是固定的，不会被这些中间文件代替，有利于调式分析。 PHP中的全局变量宏一些类似PG(),EG()之类的函数，他们都是PHP中定义的宏，主要作用是解决线程安全所写的全局变量包裹宏，如$PHP_SRC/main/php_globals.h文件就包含了这类宏。例如PG这个PHP核心全局变量宏。1234567#ifdef ZTS // 编译时开启了线程安全则使用线程安全库# define PG(v) TSRMG(core_globals_id, php_core_globals *, v)extern PHPAPI int core_globals_id;#else# define PG(v) (core_globals.v) // 否则这其实就是一个普通的全局变量extern ZEND_API struct _php_core_globals core_globals;#endif 如上，ZTS是线程安全的标记，PHP运行时的一些全局参数，如下结构体：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct _php_core_globals &#123; zend_bool magic_quotes_gpc; // 是否对输入的GET/POST/Cookie数据使用自动字符串转义。 zend_bool magic_quotes_runtime; //是否对运行时从外部资源产生的数据使用自动字符串转义 zend_bool magic_quotes_sybase; // 是否采用Sybase形式的自动字符串转义 zend_bool safe_mode; // 是否启用安全模式 zend_bool allow_call_time_pass_reference; //是否强迫在函数调用时按引用传递参数 zend_bool implicit_flush; //是否要求PHP输出层在每个输出块之后自动刷新数据 long output_buffering; //输出缓冲区大小(字节) char *safe_mode_include_dir; //在安全模式下，该组目录和其子目录下的文件被包含时，将跳过UID/GID检查。 zend_bool safe_mode_gid; //在安全模式下，默认在访问文件时会做UID比较检查 zend_bool sql_safe_mode; zend_bool enable_dl; //是否允许使用dl()函数。dl()函数仅在将PHP作为apache模块安装时才有效。 char *output_handler; // 将所有脚本的输出重定向到一个输出处理函数。 char *unserialize_callback_func; // 如果解序列化处理器需要实例化一个未定义的类，这里指定的回调函数将以该未定义类的名字作为参数被unserialize()调用， long serialize_precision; //将浮点型和双精度型数据序列化存储时的精度(有效位数)。 char *safe_mode_exec_dir; //在安全模式下，只有该目录下的可执行程序才允许被执行系统程序的函数执行。 long memory_limit; //一个脚本所能够申请到的最大内存字节数(可以使用K和M作为单位)。 long max_input_time; // 每个脚本解析输入数据(POST, GET, upload)的最大允许时间(秒)。 zend_bool track_errors; //是否在变量$php_errormsg中保存最近一个错误或警告消息。 zend_bool display_errors; //是否将错误信息作为输出的一部分显示。 zend_bool display_startup_errors; //是否显示PHP启动时的错误。 zend_bool log_errors; // 是否在日志文件里记录错误，具体在哪里记录取决于error_log指令 long log_errors_max_len; //设置错误日志中附加的与错误信息相关联的错误源的最大长度。 zend_bool ignore_repeated_errors; // 记录错误日志时是否忽略重复的错误信息。 zend_bool ignore_repeated_source; //是否在忽略重复的错误信息时忽略重复的错误源。 zend_bool report_memleaks; //是否报告内存泄漏。 char *error_log; //将错误日志记录到哪个文件中。 char *doc_root; //PHP的”根目录”。 char *user_dir; //告诉php在使用 /~username 打开脚本时到哪个目录下去找 char *include_path; //指定一组目录用于require(), include(), fopen_with_path()函数寻找文件。 char *open_basedir; // 将PHP允许操作的所有文件(包括文件自身)都限制在此组目录列表下。 char *extension_dir; //存放扩展库(模块)的目录，也就是PHP用来寻找动态扩展模块的目录。 char *upload_tmp_dir; // 文件上传时存放文件的临时目录 long upload_max_filesize; // 允许上传的文件的最大尺寸。 char *error_append_string; // 用于错误信息后输出的字符串 char *error_prepend_string; //用于错误信息前输出的字符串 char *auto_prepend_file; //指定在主文件之前自动解析的文件名。 char *auto_append_file; //指定在主文件之后自动解析的文件名。 arg_separators arg_separator; //PHP所产生的URL中用来分隔参数的分隔符。 char *variables_order; // PHP注册 Environment, GET, POST, Cookie, Server 变量的顺序。 HashTable rfc1867_protected_variables; // RFC1867保护的变量名，在main/rfc1867.c文件中有用到此变量 short connection_status; // 连接状态，有三个状态，正常，中断，超时 short ignore_user_abort; // 是否即使在用户中止请求后也坚持完成整个请求。 unsigned char header_is_being_sent; // 是否头信息正在发送 zend_llist tick_functions; // 仅在main目录下的php_ticks.c文件中有用到，此处定义的函数在register_tick_function等函数中有用到。 zval *http_globals[6]; // 存放GET、POST、SERVER等信息 zend_bool expose_php; // 是否展示php的信息 zend_bool register_globals; // 是否将 E, G, P, C, S 变量注册为全局变量。 zend_bool register_long_arrays; // 是否启用旧式的长式数组(HTTP_*_VARS)。 zend_bool register_argc_argv; // 是否声明$argv和$argc全局变量(包含用GET方法的信息)。 zend_bool auto_globals_jit; // 是否仅在使用到$_SERVER和$_ENV变量时才创建(而不是在脚本一启动时就自动创建)。 zend_bool y2k_compliance; //是否强制打开2000年适应(可能在非Y2K适应的浏览器中导致问题)。 char *docref_root; // 如果打开了html_errors指令，PHP将会在出错信息上显示超连接， char *docref_ext; //指定文件的扩展名(必须含有’.')。 zend_bool html_errors; //是否在出错信息中使用HTML标记。 zend_bool xmlrpc_errors; long xmlrpc_error_number; zend_bool activated_auto_globals[8]; zend_bool modules_activated; // 是否已经激活模块 zend_bool file_uploads; //是否允许HTTP文件上传。 zend_bool during_request_startup; //是否在请求初始化过程中 zend_bool allow_url_fopen; //是否允许打开远程文件 zend_bool always_populate_raw_post_data; //是否总是生成$HTTP_RAW_POST_DATA变量(原始POST数据)。 zend_bool report_zend_debug; // 是否打开zend debug，仅在main/main.c文件中有使用。 int last_error_type; // 最后的错误类型 char *last_error_message; // 最后的错误信息 char *last_error_file; // 最后的错误文件 int last_error_lineno; // 最后的错误行 char *disable_functions; //该指令接受一个用逗号分隔的函数名列表，以禁用特定的函数。 char *disable_classes; //该指令接受一个用逗号分隔的类名列表，以禁用特定的类。 zend_bool allow_url_include; //是否允许include/require远程文件。 zend_bool exit_on_timeout; // 超时则退出#ifdef PHP_WIN32 zend_bool com_initialized;#endif long max_input_nesting_level; //最大的嵌套层数 zend_bool in_user_include; //是否在用户包含空间 char *user_ini_filename; // 用户的ini文件名 long user_ini_cache_ttl; // ini缓存过期限制 char *request_order; // 优先级比variables_order高，在request变量生成时用到，个人觉得是历史遗留问题 zend_bool mail_x_header; // 仅在ext/standard/mail.c文件中使用， char *mail_log; zend_bool in_error_log;&#125;; 上面的字段很大一部分是与php.ini文件中的配置项对应的。在PHP启动并读取php.ini文件时就会对这些字段进行赋值，而用户空间的ini_get()及ini_set()函数操作的一些配置也是对全局变量进行操作的。在php代码中很多这样的宏，这些宏和PG宏一样，都是为了将线程安全进行封装，同时通过约定的G命名来表明这是全局的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP扩展开发初试]]></title>
    <url>%2F2017%2F02%2F20%2Fphp%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[工具准备 MAC Pro 2016 PHP版本PHP 7.1.2 PHP源码 https://github.com/php/php-src.git 当前commit 8f8fb92cd0a2ef917 autoconf工具 （brew install autoconf安装） 创建扩展骨架12345## 源码路径## /Users/hg/Sites/php-src/-&gt; cd /Users/hg/Sites/php-src/ext## 扩展名称helloworld-&gt; ./ext_skel --extname=helloworld --proto=helloworld.def 执行ext_skel后会创建helloworld目录12345-&gt; cd helloworld-&gt; pwd/Users/hg/Sites/php-src/ext/helloworld-&gt; lsCREDITS EXPERIMENTAL config.m4 config.w32 helloworld.c helloworld.php php_helloworld.h tests 修改config.m41234567891011121314## 当前目录 /Users/hg/Sites/php-src/ext/helloworld/##动态编译选项，通过.so的方式链接，去掉dnl注释dnl If your extension references something external, use with:dnl PHP_ARG_WITH(helloworld, for helloworld support,dnl Make sure that the comment is aligned:dnl [ --with-helloworld Include helloworld support])##静态编译选项，通过enable来启用，去掉dnl注释dnl Otherwise use enable:dnl PHP_ARG_ENABLE(helloworld, whether to enable helloworld support,dnl Make sure that the comment is aligned:dnl [ --enable-helloworld Enable helloworld support]) 使用动态编译123PHP_ARG_WITH(helloworld, for helloworld support,Make sure that the comment is aligned:[ --with-helloworld Include helloworld support]) 创建helloWorld函数12345678910111213141516171819-&gt; vim helloworld.cPHP_FUNCTION(confirm_helloworld_compiled)&#123; ....&#125;#### 这是新增的函数PHP_FUNCTION(sayHello)&#123; php_printf("Hello World!\n"); RETURN_TRUE;&#125;const zend_function_entry helloworld_functions[] = &#123; PHP_FE(confirm_helloworld_compiled, NULL) /* For testing, remove later. */ PHP_FE(sayHello, NULL) ## 这是新增一行 PHP_FE_END /* Must be the last line in helloworld_functions[] */&#125;; 编译 因为我的电脑里有多个版本的php，所以指定了phpize和php-config 12345678## 本地php安装路径-&gt;pwd/Users/hg/Sites/php-src/ext/helloworld/-&gt; /usr/local/Cellar/php71/7.1.2_13/bin/phpize-&gt; ./configure --with-php-config=usr/local/Cellar/php71/7.1.2_13/bin/php-config-&gt; make-&gt; make installInstalling shared extensions: /usr/local/Cellar/php71/7.1.2_13/lib/php/extensions/no-debug-non-zts-20160303/ 测试1234-&gt; pwd/Users/hg/Sites/php-src/ext/helloworld/-&gt; php -d enable_dl=On -r "dl('helloworld.so');sayHello();"Hello World! 配置php.ini1extension=/usr/local/Cellar/php71/7.1.2_13/lib/php/extensions/no-debug-non-zts-20160303/helloworld.so 使用12&lt;?phpecho sayHello();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习-高级特性]]></title>
    <url>%2F2017%2F02%2F06%2Fpython%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[迭代器 迭代我们用一个循环来遍历容器中的元素时，这种遍历过程就叫迭代 可迭代对象含有__iter__()方法或__getitem__()方法的对象称之为可迭代对象123456789101112131415161718192021222324252627# 用hasattr判断是否可迭代&gt;&gt;&gt; hasattr((), '__iter__')True&gt;&gt;&gt; hasattr([], '__iter__')True&gt;&gt;&gt; hasattr(&#123;&#125;, '__iter__')True&gt;&gt;&gt; hasattr(123, '__iter__')False&gt;&gt;&gt; hasattr('abc', '__iter__')True&gt;&gt;&gt; hasattr('abc', '__getitem__')True&gt;&gt;&gt;# isinstance进行判断&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance((), Iterable)True&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance(123, Iterable)False&gt;&gt;&gt; 可见，字典、元组、集合和字符串对象都是可迭代的迭代器是指遵循迭代器协议的对象。迭代器协议： 是指要实现对象的iter() 和next()方法，其中,__iter()__方法返回迭代器对象本身，__next__()方法返回容器的下一个元素，在没有后续元素时抛出StopIteration异常。 12345678910111213&gt;&gt;&gt; hasattr((), '__iter__')True&gt;&gt;&gt; hasattr((1, 2, 3), '__iter__')True&gt;&gt;&gt; hasattr((1, 2, 3), '__next__') # 有__iter__方法但没有__next__方法，不是迭代器False&gt;&gt;&gt; hasattr((), '__next__')False&gt;&gt;&gt; hasattr([1, 2, 3], '__iter__')True&gt;&gt;&gt; hasattr([1, 2, 3], '__next__')False&gt;&gt;&gt; 生成器生成器也是一种迭代器，在每次迭代时返回一个值，直到抛出StopIteration异常。有两种构造方式： 生成器表达式和推导式定义类似，生成器表达式使用()而不是[]123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; numbers = (x for x in range(5))&gt;&gt;&gt; for num in numbers:... print(num)...01234&gt;&gt;&gt;``` * 生成器函数含有`yield`关键字的函数，调用该函数时会返回一个生成器。```python&gt;&gt;&gt; def generator_function():... print('hello 1')... yield 1... print('hello 2')... yield 2... print('hello 3')...&gt;&gt;&gt; g = generator_function()&gt;&gt;&gt; dir(g)['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']&gt;&gt;&gt; g.__next__&lt;method-wrapper '__next__' of generator object at 0x10d86ad00&gt;&gt;&gt;&gt; g.__next__()hello 11&gt;&gt;&gt; g.__next__()hello 22&gt;&gt;&gt; g.__next__()hello 3Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt; 123456789101112131415161718192021222324252627# 自定义迭代器&gt;&gt;&gt; class Fib(object):... def __init__(self):... self.a, self.b = 0, 1... def __iter__(self):... return self... def __next__(self):... self.a, self.b = self.b, self.a + self.b... return self.a...&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; type(f)&lt;class '__main__.Fib'&gt;&gt;&gt;&gt; dir(f)['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__next__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b']&gt;&gt;&gt; for item in f:... if item &gt; 10:... break... print(item)...112358&gt;&gt;&gt; 123456789101112131415161718192021222324# 使用生成器&gt;&gt;&gt; def fib():... a, b = 0, 1... while True:... a, b = b, a + b... yield a...&gt;&gt;&gt; f = fib()&gt;&gt;&gt; type(f)&lt;class 'generator'&gt;&gt;&gt;&gt; dir(f)['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']&gt;&gt;&gt; for item in f:... if item &gt; 10:... break... print(item)...112358&gt;&gt;&gt; 1234567891011121314151617181920212223242526272829# send()&gt;&gt;&gt; def generator_function():... value1 = yield 0... print('value1 is ', value1)... value2 = yield 1... print('value2 is ', value2)... value3 = yield 2... print('value3 is ', value3)... value4 = yield 3... print('value4 is ', value4)...&gt;&gt;&gt; g = generator_function()&gt;&gt;&gt; g.__next__()0&gt;&gt;&gt; g.send(1)value1 is 11&gt;&gt;&gt; g.send(2)value2 is 22&gt;&gt;&gt; g.send(3)value3 is 33&gt;&gt;&gt; g.send(4)value4 is 4Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration&gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习-类]]></title>
    <url>%2F2017%2F01%2F23%2Fpython%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类和实例1234567891011121314151617&gt;&gt;&gt; class A(object):... pass...&gt;&gt;&gt; a = A()&gt;&gt;&gt; a&lt;__main__.A object at 0x10bc597f0&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Animal(object):... def __init__(self, name):... self.name = name... def greet(self):... print('Hello, I am %s.' % self.name)...&gt;&gt;&gt; a = Animal('hanguang')&gt;&gt;&gt; a.greet()Hello, I am hanguang.&gt;&gt;&gt; 获取对象信息 type 123&gt;&gt;&gt; a = 'hanguang'&gt;&gt;&gt; type(a)str isinstance 12&gt;&gt;&gt; isinstance(a, A)True hasattr(obj, attr) getattr(obj, attr[, default]) setattr(obj, attr, value) dir(obj)继承1234567891011121314151617&gt;&gt;&gt; class Animal(object):... def __init__(self, name):... self.name = name... def greet(self):... print('Hello, I am %s.' % self.name)...&gt;&gt;&gt; a = Animal('hanguang')&gt;&gt;&gt; a.greet()Hello, I am hanguang.&gt;&gt;&gt; class Dog(Animal):... def greet(self):... print('wang wang.., I am %s.' % self.name)...&gt;&gt;&gt; b = Dog('rabbit')&gt;&gt;&gt; b.greet()wang wang.., I am rabbit.&gt;&gt;&gt; 定制类和魔术方法 __init__ __new__ __str__ __repr__ __iter__ __getitem__ __setitem__ __delitem__ __getattr__ __serattr__ __delattr__ __call__ __slots__ 使用@property1234567891011121314151617181920212223242526# @property把方法变成了属性&gt;&gt;&gt; class Exam(object):... def __init__(self, score):... self._score = score... @property... def score(self):... return self._score... @score.setter... def score(self, val):... if val &lt; 0:... self._score = 0... elif val &gt; 100:... self._score = 100... else:... self._score = val...&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 90&gt;&gt;&gt; e.score90&gt;&gt;&gt; e.score = 200&gt;&gt;&gt; e.score100&gt;&gt;&gt; 使用super12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; class Animal(object):... def __init__(self, name):... self.name = name... def greet(self):... print('Hello, I am %s.' % self.name)...&gt;&gt;&gt; class Dog(Animal):... def greet(self):... super().greet() # 调用父类的方法... print('wang wang...')...&gt;&gt;&gt; dog = Dog('xiaoxiao')&gt;&gt;&gt; dog.greet()Hello, I am xiaoxiao.wang wang...&gt;&gt;&gt;# super 最常见用法是在子类中调用父类的初始化方法&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Base(object):... def __init__(self, a, b):... self.a = a... self.b = b...&gt;&gt;&gt; class A(Base):... def __init__(self, a, b, c):... super().__inin__(a, b)... self.c = c... 123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; class Base(object):... def __init__(self):... print('enter Base')... print('leave Base')...&gt;&gt;&gt; class A(Base):... def __init__(self):... print('enter A')... super().__init__()... print('leave A')...&gt;&gt;&gt; class B(Base):... def __init__(self):... print('enter B')... super().__init__()... print('leave B')...&gt;&gt;&gt; class C(A, B):... def __init__(self):... print('enter C')... super().__init__()... print('leave C')...&gt;&gt;&gt; c = C()enter Center Aenter Benter Baseleave Baseleave Bleave Aleave C&gt;&gt;&gt;&gt;&gt;&gt; C.mro()[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]&gt;&gt;&gt;# 子类永远在父类前面# 如果有多个父类，会根据他们在列表中的顺序被检查# 如果对下一个类存在两个合法的选择，选择第一个父类]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习-函数]]></title>
    <url>%2F2017%2F01%2F22%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数参数 默认参数应该使用不可变对象作为函数的默认参数 可变参数 1234567891011121314&gt;&gt;&gt; def add(*numbers): #参数numbers接收到的是一个tuple... sum = 0... for i in numbers:... sum += i... print('numbers:', numbers)... return sum...&gt;&gt;&gt; add(1, 2, 3)numbers: (1, 2, 3)6&gt;&gt;&gt; a = [1, 3, 4, 5, 6]&gt;&gt;&gt; add(*a) # 使用*a给函数传递参数numbers: (1, 3, 4, 5, 6)19 关键字参数允许将不定长度的键值对作为参数传递给一个函数 123456789101112131415161718&gt;&gt;&gt; def add(**kwargs):... return kwargs...&gt;&gt;&gt; add()&#123;&#125;&gt;&gt;&gt; add(x=1)&#123;'x': 1&#125;&gt;&gt;&gt; add(x=1, y=2)&#123;'x': 1, 'y': 2&#125;&gt;&gt;&gt; add(x=1, y=2, x=3) File "&lt;stdin&gt;", line 1SyntaxError: keyword argument repeated&gt;&gt;&gt; add(x=1, y=2, z=3)&#123;'x': 1, 'y': 2, 'z': 3&#125;&gt;&gt;&gt; dict = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; add(**dict)&#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; 函数式编程函数式编程是一种编程范式，或者说是编程模式，比如过程式、面向对象都是一种编程范式 高阶函数 12345678910111213141516&gt;&gt;&gt; def double(x):... return 2 * x...&gt;&gt;&gt; def square(x):... return x * x...&gt;&gt;&gt; def func(g, arr):... return [g(x) for x in arr]...&gt;&gt;&gt; arr1 = func(double, [1, 2, 3, 4])&gt;&gt;&gt; arr1[2, 4, 6, 8]&gt;&gt;&gt; arr2 = func(square, [1, 2, 3, 4])&gt;&gt;&gt; arr2[1, 4, 9, 16]&gt;&gt;&gt; mapmap(function, squence)解释：对sequence中的item依次执行function(item),并将结果组成一个list返回 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; def square(x):... return x * x...&gt;&gt;&gt; rs = map(square, [1, 2, 3, 4, 5])&gt;&gt;&gt; list(rs)[1, 4, 9, 16, 25]&gt;&gt;&gt; list(rs)[]&gt;&gt;&gt; rs = map(lambda x: x * x, [1, 2, 3, 4])&gt;&gt;&gt; list(rs)[1, 4, 9, 16]&gt;&gt;&gt; rs = map(str, [1, 2, 3, 4])&gt;&gt;&gt; list(rs)['1', '2', '3', '4']&gt;&gt;&gt;&gt;&gt;&gt; def double(x):... return 2 * x...&gt;&gt;&gt; def triple(x):... return 3 * x...&gt;&gt;&gt; def square(x):... return x * x...&gt;&gt;&gt; funcs = [double, triple, square]&gt;&gt;&gt; value = list(map(lambda f: f(4), funcs))&gt;&gt;&gt; print(value)[8, 12, 16]&gt;&gt;&gt; reducereduce(function, sequence[, initial])解释：先将sequence的前两个item传给function，即function(item1, item2),函数的返回值和sequence的下一个item再传给function，即function(function(item1, item2), item3),如此迭代，直到sequence没有元素。如果没有initial，则作为初始值调用。 123456789&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4]) #相当于((1*2)*3)*424&gt;&gt;&gt; reduce(lambda x, y: x / y, [2, 3, 4], 72) #相当于(((72 / 2)) / 3) /43.0&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10&gt;&gt;&gt; filterfilter(function, sequnce) 123&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1 , 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6] 匿名函数lambda 参数: 表达式 1234567&gt;&gt;&gt; (lambda x: 2 * x)(8)16&gt;&gt;&gt; f = lambda x: 2 * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x10bc5a048&gt;&gt;&gt;&gt; f(8)16 闭包一个函数返回一个内部函数，该内部函数引用了外部函数的相关参数和变量，我们把该返回的内部函数称为闭包(Closure) 123456789101112131415161718192021&gt;&gt;&gt; from math import pow&gt;&gt;&gt; def make_pow(n):... def inner_func(x): # inner_func 就是一个闭包，它引用了自由变量n。... return pow(x, n)... return inner_func...&gt;&gt;&gt; pow2 = make_pow(2)&gt;&gt;&gt; pow2&lt;function make_pow.&lt;locals&gt;.inner_func at 0x10bc5a158&gt;&gt;&gt;&gt; pow2(6)36.0&gt;&gt;&gt; pow2(10)100.0&gt;&gt;&gt; del make_pow # 删除make_pow&gt;&gt;&gt; pow3 = make_pow(3)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'make_pow' is not defined&gt;&gt;&gt; pow2(2) # pow2仍可正常调用，自由变量2仍保存在pow2中4.0&gt;&gt;&gt; 12345678910111213141516171819202122# 构建一个类，用于求一个点到另一个点的距离&gt;&gt;&gt; from math import sqrt&gt;&gt;&gt; class Point(object):... def __init__(self, x, y):... self.x, self.y = x, y... def get_distance(self, u, v):... distance = sqrt((self.x - u) ** 2 + (self.y - v) ** 2)... return distance...&gt;&gt;&gt; pt = Point(7, 2)&gt;&gt;&gt; pt.get_distance(10, 6)5.0# 使用闭包实现&gt;&gt;&gt; def point(x, y):... def get_distance(u, v):... return sqrt((x - u) ** 2 + (y - v) ** 2)... return get_distance...&gt;&gt;&gt; pt = point(7, 2)&gt;&gt;&gt; pt(10, 6)5.0&gt;&gt;&gt; 装饰器123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def hello():... return 'hello world'...&gt;&gt;&gt; def makeitalic(func):... def wrapped():... return '&lt;i&gt;' + func() + '&lt;/i&gt;'... return wrapped...&gt;&gt;&gt; hello = makeitalic(hello)&gt;&gt;&gt; hello()'&lt;i&gt;hello world&lt;/i&gt;'&gt;&gt;&gt; hello.__name__'wrapped'# makeitalic就是一个装饰器，它装饰了函数hello，# 并返回一个函数，将其赋给hello。# 一般情况下，我们使用装饰器提供的@语法糖，# 来简化上面的写法：&gt;&gt;&gt;&gt;&gt;&gt; def makeitalic(func):... def wrapped():... return '&lt;i&gt;' + func() + '&lt;/i&gt;'... return wrapped...&gt;&gt;&gt; @makeitalic... def hello():... return 'hello world'...&gt;&gt;&gt; hello()'&lt;i&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/i&gt;'&gt;&gt;&gt; 1234567891011121314151617181920# 对带参数的函数进行装饰&gt;&gt;&gt; def makeitalic(func):... def wrapped(*args, **kwargs):... ret = func(*args, **kwargs)... return '&lt;i&gt;' + ret + '&lt;/i&gt;'... return wrapped...&gt;&gt;&gt; @makeitalic... def hello(name):... return 'hello %s' % name...&gt;&gt;&gt; @makeitalic... def hello2(name1, name2):... return 'hello %s, %s' % (name1, name2)...&gt;&gt;&gt; hello('hanguang')'&lt;i&gt;hello hanguang&lt;/i&gt;'&gt;&gt;&gt; hello2('hanguang', 'xiyanyan')'&lt;i&gt;hello hanguang, xiyanyan&lt;/i&gt;'&gt;&gt;&gt; 123456789101112131415161718192021222324252627# 由于装饰器的副作用，被装饰的函数，它的函数名已经不是原来的名称了&gt;&gt;&gt; def makeitalic(func):... def wrappend():... return '&lt;i&gt;' + func + '&lt;/i&gt;'... return wrappend...&gt;&gt;&gt; @makeitalic... def hello():... return 'hello world'...&gt;&gt;&gt; hello.__name__'wrapped'# 为了消除这样的副作用，functool包提供了一个wraps的装饰器&gt;&gt;&gt; from functools import wraps&gt;&gt;&gt; def makeitalic(func):... @wraps(func)... def wrapped():... return '&lt;i&gt;' + func() + '&lt;/i&gt;'... return wrapped...&gt;&gt;&gt; @makeitalic... def hello():... return 'hello world'...&gt;&gt;&gt; hello.__name__'hello'&gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习-数据类型]]></title>
    <url>%2F2017%2F01%2F18%2Fpython%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[常用数据类型 序列 (sequence)序列是python最基本的数据结构。所有序列类型否可以进行某些通用的操作： 索引 分片 迭代 加 乘还可以检查某个元素是否属于序列的成员，计算序列的长度等。 列表 (list) 元组 (tuple) 字符串 (string) 字典 (dict) 集合 (set)列表、元组和字符串都属于序列类型，它们可以进行某些通用的操作，比如索引、分片等；字典属于映射类型，每个元素有键和值构成；集合是一种特殊的类型，它包含的元素是不重复的。序列1234567891011# 索引&gt;&gt;&gt; nums = [1, 2, 3, 4, 5] #列表&gt;&gt;&gt; nums[0]1&gt;&gt;&gt; nums[1]2&gt;&gt;&gt; nums[-1]5&gt;&gt;&gt; s = 'abcdef' #字符串&gt;&gt;&gt; s[0]'a' 123456789101112131415161718192021222324# 分片&gt;&gt;&gt; nums = [1, 2, 3, 4, 5, 6] #列表分片&gt;&gt;&gt; nums[-2][4, 5]&gt;&gt;&gt; nums[-3:][4, 5, 6]&gt;&gt;&gt; nums[:-3][1, 2, 3]&gt;&gt;&gt; nums[0:2][1, 2]&gt;&gt;&gt; nums[2:5][3, 4, 5]&gt;&gt;&gt; nums[0:4:2][1, 3]&gt;&gt;&gt; nums[::2][1, 3, 5]&gt;&gt;&gt; nums[:][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; s = "hello,world" #字符串分片&gt;&gt;&gt; s[0:5]'hello'&gt;&gt;&gt; a = (2, 4, 6, 8, 10) #元组分片&gt;&gt;&gt; a[2:4](6, 8) 分片使用总结 left_index:right_index:step 左边索引的元素包括在结果之中，右边索引的元素不包括在结果之中 当使用一个负数作为步长时，必须让左边索引大于右边索引 对正数步长，从左向右取元素；对负数步长，从右向左取元素12345678# 加# 两种类型相同的序列才能相加操作&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6][1, 2, 3, 4, 5,6]&gt;&gt;&gt; (1, 2, 3) + (4, 5, 6)(1, 2, 3, 4, 5, 6)&gt;&gt;&gt; 'hello,' + 'world!''hello,world!' 1234567# 乘&gt;&gt;&gt; 'abc' * 3'abcabcabc'&gt;&gt;&gt; [0] * 3[0, 0, 0]&gt;&gt;&gt; [1, 2, 3] * 3[1, 2, 3, 1, 2, 3, 1, 2, 3] 12345678# in# 检查一个值是否在序列中&gt;&gt;&gt; 'he' in 'hello'True&gt;&gt;&gt; 'hl' in 'hello'False&gt;&gt;&gt; 10 in [6, 8, 10]True 列表字符串和元组是不可变的，而列表时可变的，可以对它进行随意修改。我们还可以将字符串和元组转换成列表，只需使用list函数，比如：123456789101112131415&gt;&gt;&gt; s = 'hello'&gt;&gt;&gt; list(s)['h', 'e', 'l', 'l', 'o']&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; list(a)[1, 2, 3]``` 常用的列表方法有：* index&gt; 用于从列表中找出某个元素的weuzhi，如果有多个相同的元素，则返回第一个元素的位置。```python&gt;&gt;&gt; nums = [1, 2, 3, 4, 5, 5, 7, 8]&gt;&gt;&gt; nums.index(5) #列表有两个5，返回第一个元素的位置4 count 用于统计某个元素在列表中出现的次数。 12345&gt;&gt;&gt; nums = [1, 2, 3, 4, 5, 5, 6, 7]&gt;&gt;&gt; nums.count(2) #出现了一次1&gt;&gt;&gt; nums.count(5) #出现了两次2 append 在列表末尾增加新的元素 1234567&gt;&gt;&gt; nums = [1, 2, 3, 4]&gt;&gt;&gt; nums.append(8)&gt;&gt;&gt; nums[1, 2, 3, 4, 8]&gt;&gt;&gt; nums.append([9, 10])&gt;&gt;&gt; nums[1, 2, 3, 4, 8, [9, 10]] extend 将一个新列表元素添加到原列表中 123456789&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [4, 5, 6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a.extend(3) # 报错&gt;&gt;&gt; a.extend([3])&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6, 3] insert 将某个元素添加到某个位置 1234&gt;&gt;&gt; nums = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; nums.insert(3, 9)&gt;&gt;&gt; nums[1, 2, 3, 9, 4, 5, 6] pop 用于移除列表中的一个元素（默认是最后一个），并返回该元素的值。 123456789&gt;&gt;&gt; nums = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; nums.pop()6&gt;&gt;&gt; nums[1, 2, 3, 4, 5]&gt;&gt;&gt; nums.pop(3)4&gt;&gt;&gt; nums[1, 2, 3, 5] remove 移除列表中某个匹配元素，多个匹配移除第一个 12345&gt;&gt;&gt; nums = [1, 2, 3, 5, 6, 7, 5, 8]&gt;&gt;&gt; nums.remove(5) #两个5移除第一个&gt;&gt;&gt; nums[1, 2, 3, 6, 7, 5, 8]&gt;&gt;&gt; nums.remove(9) #报错 reverse 将列表中的元素进行反转 1234&gt;&gt;&gt; nums = [1, 2, 3, 4]&gt;&gt;&gt; nums.reverse()&gt;&gt;&gt; nums[4, 3, 2, 1] sort 列表排序，改变原来的列表，而不是返回新的排序列表，sort返回值为空 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; a = [4, 3, 6, 8, 9, 1]&gt;&gt;&gt; b = a.sort() #升序&gt;&gt;&gt; b == NoneTrue&gt;&gt;&gt; a[1, 3, 4, 6, 8, 9]&gt;&gt;&gt; a.sort(reverse=True) #降序&gt;&gt;&gt; a[9, 8, 6, 4, 3, 1]&gt;&gt;&gt; a = [4, 3, 6]&gt;&gt;&gt; b = sorted(a) #返回一个排序后的列表&gt;&gt;&gt; a[4, 3, 6]&gt;&gt;&gt; b[3, 4, 6]&gt;&gt;&gt; s = ['ccc', 'a', 'bb', 'dddd']&gt;&gt;&gt; s.sort(key=len) #使用len作为键函数，根据元素长度排序&gt;&gt;&gt; s['a', 'bb', 'ccc', 'dddd']&gt;&gt;&gt; a = [4, 3, 6]&gt;&gt;&gt; sorted(a, reverse=True)[3, 4, 6]&gt;&gt;&gt; students = [ ('john', 'B', 15), ('jane', 'A', 12), ('ethan', 'C', 12)]&gt;&gt;&gt; sorted(students, key=lambda students:students[2]) #对第3列升序[('ethan', 'C', 12),('jane', 'A', 12),('john', 'B', 15)] 元组在python中，元组是一种不可变序列 1234567891011121314151617&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; a(1, 2, 3)&gt;&gt;&gt; a[0] = 6 #报错，元组不可变，不能进行赋值操作&gt;&gt;&gt; a = () #定义空元组&gt;&gt;&gt; a()&gt;&gt;&gt; a = (12,) #在值后面加一个逗号，才是元组&gt;&gt;&gt; a(12,)&gt;&gt;&gt; type(a)&lt;type 'tuple'&gt;&gt;&gt;&gt; b = (12) #使用括号括起来，没加逗号，不是元组，本质上是b=12&gt;&gt;&gt; b12&gt;&gt;&gt; type(b)&lt;type 'int'&gt; 元组也是一种序列，也可进行索引、分片等。由于不可变，因此没有类似列表的append，extend，sort等方法。 字符串123456789&gt;&gt;&gt; s = 'hello,'&gt;&gt;&gt; s[0]'h'&gt;&gt;&gt; s[1:3]'el'&gt;&gt;&gt; s + 'world''hello, world'&gt;&gt;&gt; s * 2'hello,hello,' 字符串和元组一样，也是不可变的，所以你不能对它进行赋值等操作。 join lower upper find 在字符串中查找子串，它返回子串所在位置的最左端索引，如果没有返回-1 1234567&gt;&gt;&gt; motto = "to be or not to be, that is a question"&gt;&gt;&gt; motto.find('be')3&gt;&gt;&gt; motto.find('be', 4) #从指定位置开始查找16&gt;&gt;&gt; motto.find('be', 4, 7) #从指定起始位置和终止位置，没有找到-1 split 字符串分割成序列。不提供分隔符，默认使用所有空格（空格、制表符、换行等）分割 123456&gt;&gt;&gt; '/user/bin/ssh'.split('/')['', 'uesr', 'bin', 'ssh']&gt;&gt;&gt; '1+2+3+4+5'.split('+')['1', '2', '3', '3', '5']&gt;&gt;&gt; 'that is a question'.split() #没有提供分隔符，默认使用所有空格作为分隔符['that', 'is', 'a', 'question'] strip replace translate 字典 python中唯一的映射类型，键必须是不可变类型 1234567891011121314151617# 字典的定义&gt;&gt;&gt; d0 = &#123;&#125;&gt;&gt;&gt; d0&#123;&#125;&gt;&gt;&gt; d1 = &#123;'name': 'hanguang', 'age': 23&#125;&gt;&gt;&gt; d1&#123;'age': 23, 'name': 'hanguang'&#125;&gt;&gt;&gt; d1['age'] = 21&gt;&gt;&gt; d1&#123;'age': 21, 'name': 'hanguang'&#125;&gt;&gt;&gt; d2 = dict(name='xiyanyan', age=23) #使用dict函数&gt;&gt;&gt; d2&#123;'age': 23, 'name': 'xiyanyan'&#125;&gt;&gt;&gt; item = [('name', 'xiyanyan'), ('age', 20)]&gt;&gt;&gt; d3 = dict(item)&gt;&gt;&gt; d3&#123;'age': 20, 'name': 'xiyanyan'&#125; 123456789101112131415161718# 遍历字典&gt;&gt;&gt; d = &#123;'name': 'hanguang', 'age': 20&#125;&gt;&gt;&gt; for key in d:... print('%s: %s' % (key, d[key]))age: 20name: hanguang&gt;&gt;&gt; d['name']'hanguang'&gt;&gt;&gt; for key in d:... if key == 'name':... del d[key] #要删除字典的某一项&gt;&gt;&gt; d&#123;'age': 20&#125;&gt;&gt;&gt; dict = &#123;'name': 'xiyanyan', 'age': 20&#125;&gt;&gt;&gt; 'name' in dictTrue&gt;&gt;&gt; 'sex' in dictFalse clear 123456789101112131415161718192021&gt;&gt;&gt; d = &#123;'name': 'hanguang', 'age': 20&#125;&gt;&gt;&gt; rv = d.clear()&gt;&gt;&gt; d&#123;&#125;&gt;&gt;&gt; print(rv)None&gt;&gt;&gt; d1 = &#123;&#125;&gt;&gt;&gt; d2 = d1&gt;&gt;&gt; d2['name'] = 'hanguang'&gt;&gt;&gt; d1&#123;'name': 'hanguang'&#125;&gt;&gt;&gt; d2&#123;'name': 'hanguang'&#125;&gt;&gt;&gt; d1 = &#123;&#125; # d1变为空字典&gt;&gt;&gt; d2&#123;'name': 'hanguang'&#125; #d2不受影响&gt;&gt;&gt; d1.clear() #d1清空，d2也为空&gt;&gt;&gt; d1&#123;&#125;&gt;&gt;&gt; d2&#123;&#125; copy 实现的是浅复制。对可变对象的修改保持同步，对不可变对象保持独立 1234567891011121314151617&gt;&gt;&gt; d1 = &#123;'name': 'xiyanyan', 'books': ['book1', 'book2', 'book3']&#125;&gt;&gt;&gt; d2 = d1.copy()&gt;&gt;&gt; d2['name'] = 'hangaung' #d2对不可变对象的修改不会改变b1&gt;&gt;&gt; d2&#123;'books': ['book1', 'book2', 'book3'], 'name': 'hanguang'&#125;&gt;&gt;&gt; d1&#123;'books': ['book1', 'book2', 'book3'], 'name': 'xiyanyan'&#125;&gt;&gt;&gt; d2['books'].remove('book2') #d2对可变对象的修改影响d1&gt;&gt;&gt; d2&#123;'books': ['book1', 'book3'], 'name': 'hanguang'&#125;&gt;&gt;&gt; d1&#123;'books': ['book1', 'book3'], 'name': 'xiyanyan'&#125;&gt;&gt;&gt; d1['books'].remove('book3') #d1对可变对象的修改影响d2&gt;&gt;&gt;&gt;&gt;&gt; from copy import deepcopy&gt;&gt;&gt; d1 = &#123;'name': 'xiyanyan', 'books': ['book1', 'book2', 'book3']&#125;&gt;&gt;&gt; d2 = deepcopy(d1) # 创造一个副本，两者独立，任一方修改不会对方 get 访问字典的key，不存在不会报错 setdefault 当键不存在的时候，setdefault返回设定的默认值并更新字典。当键存在的时候，会返回已有的值，但不会更新字典。 1234567891011&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d.setdefault('name', 'hanguang')&gt;&gt;&gt; d&#123;'name': 'hanguang'&#125;&gt;&gt;&gt; d['age'] = 20&gt;&gt;&gt; d&#123;'age': 20, 'name': 'hanguang'&#125;&gt;&gt;&gt; d.setdefault('age', 18)20&gt;&gt;&gt; d&#123;'age': 20, 'name': 'hanguang'&#125; update 用于将一个字典添加到原字典，如果存在相同的键则会进行覆盖 12345678910111213&gt;&gt;&gt; d = &#123;&#125;&gt;&gt;&gt; d = &#123;'name': 'xiyanyan'&#125;&gt;&gt;&gt; d.update(d1) #将字典d1添加到d&gt;&gt;&gt; d&#123;'name': 'xiyanyan'&#125;&gt;&gt;&gt; d2 = &#123;'age': 23&#125;&gt;&gt;&gt; d.update(d2)&gt;&gt;&gt; d&#123;'age': 23, 'name': 'xiyanyan'&#125;&gt;&gt;&gt; d3 = &#123;'name': 'hanguang'&#125;&gt;&gt;&gt; d.update(d3)&gt;&gt;&gt; d&#123;'age': 23, 'name': 'hanguang'&#125; pop popitem 随机移除字段中的某个键值对 keys/iterkeys 1234567&gt;&gt;&gt; d = &#123;'name': 'xiyanyan', 'age': 20&#125;&gt;&gt;&gt; d.items()[('age', 20), ('name', 'xiyanyan')]&gt;&gt;&gt; fro k, v in d.items():... print('%s:%s % (k, v)')age: 20name: xiyanyan values/itervalues items/iteritems formkeys 集合集合（set）和字典（dict）类似，它是一组key的集合，但不存储value。集合的特性就是：key不能重复。123456789101112131415161718192021222324# 创建集合&gt;&gt;&gt; s1 = &#123;'a', 'b', 'c', 'd', 'd'&#125;&gt;&gt;&gt; s1&#123;'a', 'b', 'c', 'd'&#125;&gt;&gt;&gt; s2 = set('hanguang')&gt;&gt;&gt; s2&#123;'a', 'h', 'n', 'g', 'u'&#125;&gt;&gt;&gt; s3 = set(['.mp3', '.mp4', '.rmvb', '.mkv', '.mp3'])&gt;&gt;&gt; s3&#123;'.mkv', '.mp4', '.rmvb', '.mp3'&#125;# 遍历集合&gt;&gt;&gt; s = set(['.mp3', '.mp4', '.rmvb', '.mkv', '.mp3'])&gt;&gt;&gt; for k in s:... print(k)....mkv.mp4.rmvb.mp3# 添加元素&gt;&gt;&gt; s = &#123;'a', 'b'&#125;&gt;&gt;&gt; s.add('c')&gt;&gt;&gt; s&#123;'a', 'b', 'c'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python初学小试]]></title>
    <url>%2F2015%2F06%2F01%2Fpython%E5%88%9D%E5%AD%A6%E5%B0%8F%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2015-06-01 10:30:06# @Author : HG (hg0728@qq.com)# @Version : 1.0import urllib2import reimport os def getHtml(url): #获取html源码 page = urllib2.urlopen(url) html = page.read() return html def urlPages(page): #翻页 url = 'http://www.cnblogs.com/sitehome/p/' + str(page) #print url return url def findList(html): #正则匹配列表 myItems = re.findall('&lt;h3&gt;&lt;a class="titlelnk" href="(.*?)" target="_blank"&gt;(.*?)&lt;/a&gt;&lt;/h3&gt;', html, re.S) return myItems for page in range(1, 200+1): #抓取的页数 html = getHtml(urlPages(page)) items = findList(html) for item in items: s = item[0] +' '+ item[1] + '\n' print item[0] file_object = open('thefile.txt', 'a') file_object.write(s) file_object.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
